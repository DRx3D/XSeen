/*
 *  XSeen V0.7.41+7_f568368
 *  Built Thu Nov  8 10:25:35 2018
 *

Dual licensed under the MIT and GPL licenses.

==[MIT]====================================================================
Copyright (c) 2017, Daly Realism

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.


==[GPL]====================================================================

XSeen - Declarative 3D for HTML

Copyright (C) 2017, Daly Realism
                                                                       
This program is free software: you can redistribute it and/or modify   
it under the terms of the GNU General Public License as published by   
the Free Software Foundation, either version 3 of the License, or      
(at your option) any later version.                                    
                                                                       
This program is distributed in the hope that it will be useful,        
but WITHOUT ANY WARRANTY; without even the implied warranty of         
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          
GNU General Public License for more details.                           
                                                                       
You should have received a copy of the GNU General Public License      
along with this program.  If not, see <http://www.gnu.org/licenses/>.


=== COPYRIGHT +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (C) 2017, Daly Realism for XSeen
Copyright, Fraunhofer for X3DOM
Copyright, Mozilla for A-Frame
Copyright, THREE and Khronos for various parts of THREE.js
Copyright (C) 2017, John Carlson for JSON->XML converter (JSONParser.js)

===  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 */
var XSeen = XSeen || {};
XSeen.CameraManager = {
'PRIORITY_MINIMUM'	: 0,
'PRIORITY_DEFAULT'	: 1,
'FOV'				: 50,		// Vertical field-of-view
'NearClip'			: 0.1,
'FarClip'			: 10000,
'DefinedCameras'	: [],		// Contains references to camera nodes ...[priority][order]
'CurrentNode'		: null,
'create'			: function (aspectRatio)
{
camera = new THREE.PerspectiveCamera( this.FOV, aspectRatio, this.NearClip, this.FarClip );
return camera;
},
'reset'				: function (camera, aspectRatio)
{
camera.aspect = aspectRatio;
camera.far = this.FarClip;
camera.fov = this.FOV;
camera.near = this.NearClip;
camera.updateProjectionMatrix ();
return camera;
},
'add'				: function (camera)
{
console.log ('Adding camera#' + camera.id + ' to the list');
if (typeof(this.DefinedCameras[camera._xseen.priority]) == 'undefined') {this.DefinedCameras[camera._xseen.priority] = [];}
this.DefinedCameras[camera._xseen.priority].push (camera);
camera._xseen.ndxCamera = this.DefinedCameras[camera._xseen.priority].length - 1;
camera.setActive = function() {
camera._xseen.sceneInfo.ViewManager.setActive (this);
}
console.log ('.. returning from camera.add');
},
'next'				: function ()
{
for (var p=this.DefinedCameras.length-1; p>=this.PRIORITY_MINIMUM; p--) {
if (typeof(this.DefinedCameras[p]) != 'undefined') {
for (var ii=0; ii<this.DefinedCameras[p].length; ii++) {
if (this.DefinedCameras[p][ii]._xseen.available) {return this.DefinedCameras[p][ii];}
}
}
}
return this.DefinedCameras[this.PRIORITY_MINIMUM][0];	// System default
},
'setActive'			: function (cameraElement)
{
if (cameraElement === null) {return;}
if (this.CurrentNode !== null) {this.CurrentNode._xseen.active = false;}
cameraElement._xseen.active = true;
var xRuntime = cameraElement._xseen.sceneInfo;
this.reset (xRuntime.Camera, xRuntime.Size.aspect);
if (cameraElement._xseen.isStereographic) {
xRuntime.Renderer = xRuntime.RendererStereo;
xRuntime.rendererHasControls = false;
xRuntime.isStereographic = true;
} else {
xRuntime.Renderer = xRuntime.RendererStandard;
xRuntime.rendererHasControls = cameraElement._xseen.rendererHasControls;
xRuntime.isStereographic = false;
xRuntime.Renderer.setScissorTest( false );
var size = xRuntime.Renderer.getSize();
xRuntime.Renderer.setScissor( 0, 0, size.width, size.height );
xRuntime.Renderer.setViewport( 0, 0, size.width, size.height );
}
xRuntime.Camera.position.set (
cameraElement._xseen.attributes.position.x,
cameraElement._xseen.attributes.position.y,
cameraElement._xseen.attributes.position.z);
xRuntime.Camera.lookAt(0,0,0);		// Look at origin. Seems to be required for object type.
xRuntime.useDeviceOrientation = cameraElement._xseen.useDeviceOrientation;
if (!cameraElement._xseen.rendererHasControls) {
if (xRuntime.useDeviceOrientation) {	// Device controls camera. Set focus point
if (cameraElement._xseen.track == 'object') {	// tracking scene object
xRuntime.CameraControl = new THREE.DeviceOrientationControls(cameraElement._xseen.target, true);
} else {							// tracking environment
xRuntime.CameraControl = new THREE.DeviceOrientationControls(xRuntime.Camera);
}
} else {											// No device orientation control. Use something else
if (cameraElement._xseen.track == 'orbit') {
xRuntime.CameraControl = new THREE.OrbitControls( xRuntime.Camera, xRuntime.RendererStandard.domElement );
} else if (cameraElement._xseen.track == 'trackball') {
} else if (cameraElement._xseen.track == 'none') {
xRuntime.rendererHasControls = true;
} else {
console.log ('Something else');
}
}
}
console.log ('Setting active camera to ' + cameraElement.id);
this.CurrentNode = cameraElement;
},
'setNext'			: function ()
{
var camera = this.next();
this.setActive (camera);
console.log ('Activating camera ID: ' + camera.id + ' with controls: ' + camera._xseen.sceneInfo.rendererHasControls);
}
};
XSeen = (typeof(XSeen) === 'undefined') ? {} : XSeen;
XSeen.DefineConstants = function () {
var ColorsCS = new Object(), Colors = new Object();
ColorsCS = {
'AliceBlue'			: 0xF0F8FF,
'AntiqueWhite'		: 0xFAEBD7,
'Aqua'				: 0x00FFFF,
'Aquamarine'		: 0x7FFFD4,
'Azure'				: 0xF0FFFF,
'Beige'				: 0xF5F5DC,
'Bisque'			: 0xFFE4C4,
'Black'				: 0x000000,
'BlanchedAlmond'	: 0xFFEBCD,
'Blue'				: 0x0000FF,
'BlueViolet'		: 0x8A2BE2,
'Brown'				: 0xA52A2A,
'BurlyWood'			: 0xDEB887,
'CadetBlue'			: 0x5F9EA0,
'Chartreuse'		: 0x7FFF00,
'Chocolate'			: 0xD2691E,
'Coral'				: 0xFF7F50,
'CornflowerBlue'	: 0x6495ED,
'Cornsilk'			: 0xFFF8DC,
'Crimson'			: 0xDC143C,
'Cyan'				: 0x00FFFF,
'DarkBlue'			: 0x00008B,
'DarkCyan'			: 0x008B8B,
'DarkGoldenRod'		: 0xB8860B,
'DarkGray'			: 0xA9A9A9,
'DarkGrey'			: 0xA9A9A9,
'DarkGreen'			: 0x006400,
'DarkKhaki'			: 0xBDB76B,
'DarkMagenta'		: 0x8B008B,
'DarkOliveGreen'	: 0x556B2F,
'DarkOrange'		: 0xFF8C00,
'DarkOrchid'		: 0x9932CC,
'DarkRed'			: 0x8B0000,
'DarkSalmon'		: 0xE9967A,
'DarkSeaGreen'		: 0x8FBC8F,
'DarkSlateBlue'		: 0x483D8B,
'DarkSlateGray'		: 0x2F4F4F,
'DarkSlateGrey'		: 0x2F4F4F,
'DarkTurquoise'		: 0x00CED1,
'DarkViolet'		: 0x9400D3,
'DeepPink'			: 0xFF1493,
'DeepSkyBlue'		: 0x00BFFF,
'DimGray'			: 0x696969,
'DimGrey'			: 0x696969,
'DodgerBlue'		: 0x1E90FF,
'FireBrick'			: 0xB22222,
'FloralWhite'		: 0xFFFAF0,
'ForestGreen'		: 0x228B22,
'Fuchsia'			: 0xFF00FF,
'Gainsboro'			: 0xDCDCDC,
'GhostWhite'		: 0xF8F8FF,
'Gold'				: 0xFFD700,
'GoldenRod'			: 0xDAA520,
'Gray'				: 0x808080,
'Grey'				: 0x808080,
'Green'				: 0x008000,
'GreenYellow'		: 0xADFF2F,
'HoneyDew'			: 0xF0FFF0,
'HotPink'			: 0xFF69B4,
'IndianRed '		: 0xCD5C5C,
'Indigo '			: 0x4B0082,
'Ivory'				: 0xFFFFF0,
'Khaki'				: 0xF0E68C,
'Lavender'			: 0xE6E6FA,
'LavenderBlush'		: 0xFFF0F5,
'LawnGreen'			: 0x7CFC00,
'LemonChiffon'		: 0xFFFACD,
'LightBlue'			: 0xADD8E6,
'LightCoral'		: 0xF08080,
'LightCyan'			: 0xE0FFFF,
'LightGoldenRodYellow'	: 0xFAFAD2,
'LightGray'			: 0xD3D3D3,
'LightGrey'			: 0xD3D3D3,
'LightGreen'		: 0x90EE90,
'LightPink'			: 0xFFB6C1,
'LightSalmon'		: 0xFFA07A,
'LightSeaGreen'		: 0x20B2AA,
'LightSkyBlue'		: 0x87CEFA,
'LightSlateGray'	: 0x778899,
'LightSlateGrey'	: 0x778899,
'LightSteelBlue'	: 0xB0C4DE,
'LightYellow'		: 0xFFFFE0,
'Lime'				: 0x00FF00,
'LimeGreen'			: 0x32CD32,
'Linen'				: 0xFAF0E6,
'Magenta'			: 0xFF00FF,
'Maroon'			: 0x800000,
'MediumAquaMarine'	: 0x66CDAA,
'MediumBlue'		: 0x0000CD,
'MediumOrchid'		: 0xBA55D3,
'MediumPurple'		: 0x9370DB,
'MediumSeaGreen'	: 0x3CB371,
'MediumSlateBlue'	: 0x7B68EE,
'MediumSpringGreen'	: 0x00FA9A,
'MediumTurquoise'	: 0x48D1CC,
'MediumVioletRed'	: 0xC71585,
'MidnightBlue'		: 0x191970,
'MintCream'			: 0xF5FFFA,
'MistyRose'			: 0xFFE4E1,
'Moccasin'			: 0xFFE4B5,
'NavajoWhite'		: 0xFFDEAD,
'Navy'				: 0x000080,
'OldLace'			: 0xFDF5E6,
'Olive'				: 0x808000,
'OliveDrab'			: 0x6B8E23,
'Orange'			: 0xFFA500,
'OrangeRed'			: 0xFF4500,
'Orchid'			: 0xDA70D6,
'PaleGoldenRod'		: 0xEEE8AA,
'PaleGreen'			: 0x98FB98,
'PaleTurquoise'		: 0xAFEEEE,
'PaleVioletRed'		: 0xDB7093,
'PapayaWhip'		: 0xFFEFD5,
'PeachPuff'			: 0xFFDAB9,
'Peru'				: 0xCD853F,
'Pink'				: 0xFFC0CB,
'Plum'				: 0xDDA0DD,
'PowderBlue'		: 0xB0E0E6,
'Purple'			: 0x800080,
'RebeccaPurple'		: 0x663399,
'Red'				: 0xFF0000,
'RosyBrown'			: 0xBC8F8F,
'RoyalBlue'			: 0x4169E1,
'SaddleBrown'		: 0x8B4513,
'Salmon'			: 0xFA8072,
'SandyBrown'		: 0xF4A460,
'SeaGreen'			: 0x2E8B57,
'SeaShell'			: 0xFFF5EE,
'Sienna'			: 0xA0522D,
'Silver'			: 0xC0C0C0,
'SkyBlue'			: 0x87CEEB,
'SlateBlue'			: 0x6A5ACD,
'SlateGray'			: 0x708090,
'SlateGrey'			: 0x708090,
'Snow'				: 0xFFFAFA,
'SpringGreen'		: 0x00FF7F,
'SteelBlue'			: 0x4682B4,
'Tan'				: 0xD2B48C,
'Teal'				: 0x008080,
'Thistle'			: 0xD8BFD8,
'Tomato'			: 0xFF6347,
'Turquoise'			: 0x40E0D0,
'Violet'			: 0xEE82EE,
'Wheat'				: 0xF5DEB3,
'White'				: 0xFFFFFF,
'WhiteSmoke'		: 0xF5F5F5,
'Yellow'			: 0xFFFF00,
'YellowGreen'		: 0x9ACD32,
};
var key, value;
for (const key in ColorsCS) {
Colors[key.toLowerCase()] = ColorsCS[key];
}
return {
'Deg2Rad'	: Math.PI / 180,
'Rad2Deg'	: 180.0 / Math.PI,
'ColorsCS'	: ColorsCS,
'Colors'	: Colors,
};		
}
XSeen = (typeof(XSeen) === 'undefined') ? {} : XSeen;
XSeen.DisplayControl = {
'buttonCreate'			: function (buttonType, node, button) {
var button = document.createElement( 'div' );
button.innerHTML = "Requesting '"  + buttonType + "'";
button.style.width += 6 + buttonType.length/2 + 'em';
this.stylizeElement( button );
if (buttonType == 'fullscreen') {
this.buttonFullScreen (button, node);
} else if (buttonType == 'vr') {
this.buttonVR (button, node);
}
button._checkButtonActive = this._checkButtonActive;
button._checkButtonActive (button);
return button;
},
'buttonNotSupported'	: function (buttonType, button) {
var response = document.createElement( 'div' );
this.stylizeElement( response );
response.innerHTML = buttonType.toUpperCase() + ' is not supported';
response.style.width = '13em'
response.style.cursor = 'default';
return response;
},
'_checkButtonActive'	: function (button) {
if (button.dataset._active != 'false') {
button.onmouseenter = function(event) {
event.currentTarget.style.opacity = 1.0;
};
button.onmouseleave = function(event) {
event.currentTarget.style.opacity = 0.5;
};
} else {
button.onmouseenter = null;
button.onmouseleave = null;
button.style.opacity = 0.5;
}
},
'stylizeElement'	: function (button) {
button.style.backgroundColor	= '#212214';
button.style.height				= '24px';
button.style.backgroundImage	= 'url(../Logo/xseen-symbol-color.svg)';
button.style.backgroundRepeat	= 'no-repeat';
button.style.paddingLeft		= '70px';
button.style.borderRadius		= '4px';
button.style.cursor				= 'pointer';
button.style.fontFamily			= 'Arial,Helvetica,"sans serif"';
button.style.fontSize			= '18px';
button.style.textAlign			= 'center';
button.style.opacity			= 0.5;
button.dataset._colorDefault	= '#aaa';			// default color
button.dataset._active			= false;			// button not active
button.style.color				= button.dataset._colorDefault;
button.style.position			= 'fixed';
button.style.bottom				= '66px';
button.style.left				= '45%';
},
'buttonVR'				: function (button, node) {
showEnterVR = function (button, display ) {
button.innerHTML		= "Enter VR";
button.style.width		= '7em';
button.style.cursor		= 'pointer';
button.dataset._active	= true;			// button active
button._checkButtonActive (button);		
if (display && button) {	// Display & button defined, so go ahead and create event handler
button.onclick = function(ev) {
console.log ('Currently Presenting VR: |' + display.isPresenting + '|');
display.isPresenting ? display.exitPresent() : display.requestPresent( [ { source: renderer.domElement } ] );
renderer.vr.setDevice( display );
console.log ('VR state changed');
};
}
}
showVRNotFound = function () {
button.innerHTML		= "VR Not Found";
button.style.width		= '7em';
button.style.cursor		= 'default';
button.dataset._active	= false;			// button active
button._checkButtonActive (button);			
button.onmouseenter = null;
button.onmouseleave = null;
button.onclick = null;
}
window.addEventListener( 'vrdisplayconnect', function ( event ) {
showEnterVR( event.display );		// Problematic because need to locate 'button'
}, false );
window.addEventListener( 'vrdisplaydisconnect', function ( event ) {
showVRNotFound();
}, false );
window.addEventListener( 'vrdisplaypresentchange', function ( event ) {
button.innerHTML = event.display.isPresenting ? 'EXIT VR' : 'ENTER VR';	// See above
}, false );
navigator.getVRDisplays()
.then( function ( displays ) {
if (true ||  displays.length > 0 ) {
console.log ("Showing 'Enter VR'");
button.dataset._active	= true;			// button active
showEnterVR(button, null);
return true;
} else {
showVRNotFound ();
console.log ("Showing 'VR Not Found'");
return false;
}
} );
return button;
},
'buttonFullScreen'		: function (button, node) {
button.innerHTML		= "Enter FullScreen";
button.style.width		= '9em';
button.dataset._active	= true;			// button active
button._fullScreenNode 	= node;
node._requestFullscreen	= this._requestFullscreen;
node._exitFullscreen	= this._exitFullscreen;
node._fullscreenButton	= button;
document.documentElement._isFullScreen		= function () {
var fullScreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
if (typeof(fullScreenElement) != 'undefined') {return true;}
return false;
};
document.documentElement._fullScreenElement	= function () {
return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
};
button.addEventListener( 'click', function ( event ) {
var e = document.documentElement._fullScreenElement();
if (document.documentElement._isFullScreen()) {
event.currentTarget._fullScreenNode._exitFullscreen.call(document);
} else {
event.currentTarget._fullScreenNode._requestFullscreen();
document.documentElement._XSeenButton = event.currentTarget;	// Save the button for changing the label
}
}, false );
document.addEventListener( this._fullscreenEventName, function ( event ) {
if ( document.documentElement._isFullScreen() ) {
console.log('Need to exit');
document.documentElement._XSeenButton.innerHTML = 'Exit FullScreen';
} else {	// Exit from full screen
console.log('Need to enter');
document.documentElement._XSeenButton.innerHTML = 'Enter FullScreen';
document.documentElement._XSeenButton = null;
}
}, false );
},
'_requestFullscreen'	: document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.mozRequestFullScreen || document.documentElement.msRequestFullscreen,
'_exitFullscreen'		: document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen,
'_fullscreenEventName'	: 
(typeof(document.documentElement.requestFullscreen)			!= 'undefined') ? 'fullscreenchange' :
(typeof(document.documentElement.webkitRequestFullscreen)	!= 'undefined') ? 'webkitfullfullscreenchange' :
(typeof(document.documentElement.mozRequestFullScreen)		!= 'undefined') ? 'mozfullscreenchange' :
(typeof(document.documentElement.msRequestFullscreen)		!= 'undefined') ? 'msfullscreenchange' : '',
'_supportFullscreen'	: (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) ? true : false,
'_deviceSupportsType'	: function (buttonType) {
if (buttonType == 'fullscreen') {
return this._supportFullscreen;
} else if (buttonType == 'vr') {
if ( 'getVRDisplays' in navigator ) {
return true;
} else {
return false;
}
}
return false;
},
'createButton'			: function (type, node, renderer, button) {
var buttonType, response;
buttonType = type.toLowerCase();
if (this._deviceSupportsType(buttonType)) {	// Device supports requested feature (VR or FullScreen)
response = this.buttonCreate (buttonType, node, button);
} else {								// Device does not support requested feature (VR or FullScreen)
response = this.buttonNotSupported (buttonType, button);
}
return response;
},
};
var XSeen = XSeen || {};
XSeen.Events = {
'MODE_NAVIGATE'		: 1,
'MODE_SELECT'		: 2,
'mode'				: 1,
'inNavigation'		: function () {return (this.mode == this.MODE_NAVIGATION) ? true : false;},
'inSelect'			: function () {return (this.mode == this.MODE_SELECT) ? true : false;},
'redispatch'		: false,
'object'			: {},
'tag'				: {},
'raycaster'			: new THREE.Raycaster(),
'cursorScreen'		: new THREE.Vector2(),
'xseen'				: function (ev)
{
var xEvents = XSeen.Events;
var Runtime = ev.currentTarget._xseen.sceneInfo;
if (ev.type == 'mousedown') {
xEvents.redispatch = true;
xEvents.mode = xEvents.MODE_SELECT;
xEvents.cursorScreen.x = ev.clientX * Runtime.Size.iwidth  * 2 - 1;
xEvents.cursorScreen.y = -ev.clientY * Runtime.Size.iheight * 2 + 1;
xEvents.raycaster.setFromCamera(xEvents.cursorScreen, Runtime.Camera);
var hitGeometryList = xEvents.raycaster.intersectObjects (Runtime.selectable, true);
if (hitGeometryList.length != 0) {
xEvents.object = hitGeometryList[0];
xEvents.tag = xEvents.object.object.userData;
if (typeof(xEvents.object.object.userData) != 'undefined' && typeof(xEvents.object.object.userData.root) != 'undefined') {
xEvents.tag = xEvents.tag.root;
}
} else {
xEvents.object = {};
xEvents.redispatch = false;
xEvents.mode = xEvents.MODE_NAVIGATION;
}
}
if ((xEvents.redispatch || ev.type == 'click' || ev.type == 'dblclick') && typeof(xEvents.object.object) !== 'undefined') {
var newEv = new CustomEvent('xseen-touch', xEvents.propertiesCursor(ev, xEvents.object));
xEvents.tag.dispatchEvent(newEv);
ev.stopPropagation();		// No propagation beyond this tag
} else {
}
if (ev.type == 'mouseup') {
xEvents.redispatch = false;
xEvents.mode = xEvents.MODE_NAVIGATION;
}
},
'propertiesCursor'	: function (ev, selectedObject)
{
var properties = {
'detail':		{					// This object contains all of the XSeen data
'type':			ev.type,
'originalType':	ev.type,
'originator':	selectedObject.object.userData,
'name':			selectedObject.object.name,
'distance':		selectedObject.distance,
'target':		selectedObject,
'position': {
'x': selectedObject.point.x,
'y': selectedObject.point.y,
'z': selectedObject.point.z,
},
'normal': {
'x': selectedObject.face.normal.x,
'y': selectedObject.face.normal.y,
'z': selectedObject.face.normal.z,
},
'uv': {
'x': 0.0,		// selectedObject.uv.x,
'y': 0.0,		// selectedObject.uv.y,
},
'screenX':	ev.screenX,
'screenY':	ev.screenY,
'clientX':	ev.clientX,
'clientY':	ev.clientY,
'ctrlKey':	ev.ctrlKey,
'shiftKey':	ev.shiftKey,
'altKey': 	ev.altKey,
'metaKey':	ev.metaKey,
'button':	ev.button,
'buttons':	ev.buttons,
},
'bubbles':		ev.bubbles,
'cancelable':	ev.cancelable,
'composed':		ev.composed,
};
return  properties;
},
'propertiesRenderFrame'	: function (Runtime)
{
var properties = {
'detail':		{					// This object contains all of the XSeen data
'type'			: 'renderframe',
'originalType'	: 'renderframe',
'originator'	: Runtime.RootTag,			// Reference to scene object
'name'			: Runtime.RootTag.name,		// Name of scene object
'currentTime'	: Runtime.currentTime,		// Current time at start of frame rendering
'deltaTime'		: Runtime.deltaTime,		// Time since last frame
'frameNumber'	: Runtime.frameNumber,		// Number of frame about to be rendered
'Runtime'		: Runtime					// Reference to Runtime object
},
'bubbles':		true,
'cancelable':	true,
'composed':		true,
};
return  properties;
},
'propertiesInitialize'	: function (Runtime)
{
var properties = {
'detail':		{					// This object contains all of the XSeen data
'type'			: 'initialize',
'originalType'	: 'initialize',
'originator'	: Runtime.RootTag,			// Reference to scene object
'name'			: Runtime.RootTag.name,		// Name of scene object
'currentTime'	: Runtime.currentTime,		// Current time at start of frame rendering
'deltaTime'		: Runtime.deltaTime,		// Time since last frame
'Runtime'		: Runtime					// Reference to Runtime object
},
'bubbles':		true,
'cancelable':	true,
'composed':		true,
};
return  properties;
},
};
var XSeen = XSeen || {};
XSeen.parseUrl = function (url) {
var parser = document.createElement('a'),
searchObject = {},
queries, split, i, pathFile, path, file, extension;
parser.href = url;
queries = parser.search.replace(/^\?/, '').split('&');
for( i = 0; i < queries.length; i++ ) {
split = queries[i].split('=');
searchObject[split[0]] = split[1];
}
pathFile = parser.pathname.split('/');
file = pathFile[pathFile.length-1];
pathFile.length --;
path = '/' + pathFile.join('/');
extension = file.split('.');
extension = extension[extension.length-1];
return {
protocol:		parser.protocol,
host:			parser.host,
hostname:		parser.hostname,
port:			parser.port,
pathname:		parser.pathname,
path:			path,
file:			file,
extension:		extension,
search:			parser.search,
searchObject:	searchObject,
hash:			parser.hash
};
};
XSeen.isImage = function (url) {
var u = XSeen.parseUrl (url);
var ext = u.extension.toLowerCase();
if (ext == 'jpg' || ext == 'jpeg' || ext == 'png' || ext == 'gif') {return true;}
return false;
};
XSeen.Loader = {
'urlQueue'			: [],
'urlNext'			: -1,
'MaxRequests'		: 3,
'totalRequests'		: 0,
'totalResponses'	: 0,
'requestCount'		: 0,
'lmThat'			: this,
'manager'			: new THREE.LoadingManager(),
'loadersComplete'	: true,
'ContentType'		: {
'jpg'	: 'image',
'jpeg'	: 'image',
'gif'	: 'image',
'txt'	: 'text',
'html'	: 'html',
'htm'	: 'html',
'xml'	: 'xml',
'json'	: 'json',
'dae'	: 'collada',
'gltf'	: 'gltf',
'glb'	: 'gltfLegacy',
'obj'	: 'obj',
'x3d'	: 'x3d',
},
'ContentLoaders'	: {},
'internalLoader'	: function (url, success, failure, progress, userdata, type)
{
this.urlQueue.push( {'url':url, 'type':type, 'hint':hint, 'userdata':userdata, 'success':success, 'failure':failed, 'progress':progress} );
this.loadNextUrl();
},
'TextureCube'		: function (pathUri, filenames, filetypes, Success)
{
var urlTypes=Array(6), urls=Array(6), textureCube;
var _Success = function (data) {
var texture = data.cube, dirty;
if (typeof(data.dirty) !== undefined) {dirty = dirtyFlag;}
return function (textureCube) {
texture = textureCube;
if (typeof(dirty) !== 'undefined') {dirty = true;}
console.log ('Successful load of background textures.');
}
};
var _Progress = function (a) {
console.log ('Loading background textures...');
};
var _Failure = function (a) {
console.log ('Load failure');
console.log ('Failure to load background textures.');
};
if (typeof(filetypes) == 'string') {
urlTypes = [filetypes, filetypes, filetypes, filetypes, filetypes, filetypes];
} else if (filetypes.length == 6) {
urlTypes = filetypes;
} else {
return;
}
if (pathUri == '' && (filenames.length != 6 ||
(filesnames[0] == '' || filesnames[1] == '' || filesnames[2] == '' || filesnames[3] == '' || filesnames[4] == '' || filesnames[5] == ''))) {return;}
urls[0] = pathUri + ((filenames.length >= 1 && filenames[0] != '') ? filenames[0] : 'px') + urlTypes[0];
urls[1] = pathUri + ((filenames.length >= 2 && filenames[1] != '') ? filenames[1] : 'nx') + urlTypes[1];
urls[2] = pathUri + ((filenames.length >= 3 && filenames[2] != '') ? filenames[2] : 'py') + urlTypes[2];
urls[3] = pathUri + ((filenames.length >= 4 && filenames[3] != '') ? filenames[3] : 'ny') + urlTypes[3];
urls[4] = pathUri + ((filenames.length >= 5 && filenames[4] != '') ? filenames[4] : 'pz') + urlTypes[4];
urls[5] = pathUri + ((filenames.length >= 6 && filenames[5] != '') ? filenames[5] : 'nz') + urlTypes[5];
console.log('Loading cube-map texture...');
textureCube = new THREE.CubeTextureLoader(XSeen.Loader.manager)
.load (urls, Success, _Progress, _Failure);
},
'load'		: function (url='', hint='', success, failure, progress, userdata)
{
var uri = XSeen.parseUrl (url);
var type = (typeof(this.ContentType[uri.extension]) === 'undefined') ? this.ContentType['txt'] : this.ContentType[uri.extension];
var MimeLoader = this.ContentLoaders[type];
if (MimeLoader.needHint === true && hint == '') {
console.log ('Hint require to load content type ' + type);
return false;
}
if (MimeLoader.needHint) {
if (type == 'gltf') {
if (hint == '') {hint = 'Current';}
type += hint;
MimeLoader = this.ContentLoaders[type];
}		// Other types go here
}
if (typeof(MimeLoader.loader) === 'undefined') {
this.internalLoader (url, success, failure, progress, userdata, type);
} else {
MimeLoader.loader.load (url, success, progress, failure);
XSeen.Loader.loadersComplete = false;
}
},
'success'	: function (response, string, xhr)
{
if (typeof(xhr._loadManager.success) !== undefined) {
xhr._loadManager.success (response, xhr._loadManager.userdata, xhr);
}
},
'progress'	: function (xhr, errorCode, errorText)
{
if (typeof(xhr._loadManager.progress) !== undefined) {
xhr._loadManager.progress (xhr, xhr._loadManager.userdata, errorCode, errorText);
}
},
'failure'	: function (xhr, errorCode, errorText)
{
if (typeof(xhr._loadManager.failure) !== undefined) {
xhr._loadManager.failure (xhr, xhr._loadManager.userdata, errorCode, errorText);
}
},
'requestComplete'	: function (event, xhr, settings)
{
this.lmThat.requestCount --;
this.lmThat.totalResponses++;
this.lmThat.loadNextUrl();
},
'loadNextUrl'		: function ()
{
if (this.requestCount >= this.MaxRequests) {return; }
if (this.urlNext >= this.urlQueue.length || this.urlNext < 0) {
this.urlNext = -1;
for (var i=0; i<this.urlQueue.length; i++) {
if (this.urlQueue[i] !== null) {
this.urlNext = i;
break;
}
}
if (this.urlNext < 0) {
this.urlQueue = [];
return;
}
}
this.requestCount ++;
var details = this.urlQueue[this.urlNext];
var settings = {
'url'		: details.url,
'dataType'	: details.type,
'complete'	: this.requestComplete,
'success'	: this.success,
'error'		: this.failure
};
if (settings.dataType == 'json') {
settings['beforeSend'] = function(xhr){xhr.overrideMimeType("application/json");};
}
this.urlQueue[this.urlNext] = null;
this.urlNext ++;
var x = jQuery.get(settings);		// Need to change this... Has impact throughout class
x._loadManager = {'userdata': details.userdata, 'requestType':details.type, 'success':details.success, 'failure':details.failure};
this.totalRequests++;
},
};
XSeen.Loader.onLoad = function() {
var mgr = XSeen.Loader.manager;
XSeen.Loader.ContentLoaders = {
'image'		: {'loader': null, needHint: false, },
'text'		: {'loader': null, needHint: false, },
'html'		: {'loader': null, needHint: false, },
'xml'		: {'loader': null, needHint: false, },
'json'		: {'loader': null, needHint: false, },
'gltf'		: {'loader': null, needHint: 2, },
'collada'	: {'loader': new THREE.ColladaLoader(mgr), needHint: false, },
'obj'		: {'loader': new THREE.OBJLoader2(mgr), needHint: false, },
'x3d'		: {'loader': new THREE.ColladaLoader(mgr), needHint: false, },
'gltfCurrent'	: {'loader': new THREE.GLTFLoader(mgr), needHint: false, }, 
'gltfLegacy'	: {'loader': new THREE.LegacyGLTFLoader(mgr), needHint: false, }, 
};
console.log ('Created ContentLoaders object');
mgr.onLoad = function() {XSeen.Loader.loadersComplete = true;}
};
XSeen.Loader.loadingComplete = function() {
if (XSeen.Loader.urlQueue.length == 0 && XSeen.Loader.loadersComplete) return true;
return false;
}
if (typeof(XSeen.onLoadCallBack) === 'undefined') {
XSeen.onLoadCallBack = [];
}
XSeen.onLoadCallBack.push (XSeen.Loader.onLoad);
if (typeof(XSeen) === 'undefined') {var XSeen = {};}
if (typeof(XSeen.definitions) === 'undefined') {XSeen.definitions = {};}
XSeen.definitions.Logging = {
'levels'	: ['Info', 'Debug', 'Warn', 'Error'],
'Data'		: {
'Levels' : {
'Info'	: {'class':'xseen-log xseen-logInfo', 'level':7, label:'INFO'},
'Debug'	: {'class':'xseen-log xseen-logInfo', 'level':5, label:'DEBUG'},
'Warn'	: {'class':'xseen-log xseen-logInfo', 'level':3, label:'WARN'},
'Error'	: {'class':'xseen-log xseen-logInfo', 'level':1, label:'ERROR'},
},
'maximumLevel'		: 9,
'defaultLevel'		: 'Error',
'active'			: false,
'init'				: false,
'maxLinesLogged'	: 10000,
'lineCount'			: 0,
'logContainer'		: null,
},
'init'		: function (show, element) {
if (this.Data.init) {return this; }
if (document.getElementById('XSeenLog') === null) {
this.Data.logContainer = document.createElement("div");
this.Data.logContainer.id = "xseen_logdiv";
this.Data.logContainer.setAttribute("class", "xseen-logContainer");
this.Data.logContainer.style.clear = "both";
element.parentElement.appendChild (this.Data.logContainer);
} else {
this.Data.logContainer = document.getElementById('XSeenLog');
this.Data.logContainer.classList.add ("xseen-logContainer");
}
this.Data.init = true;
if (!show) {this.LogOff()}
return this;
},
'LogOn'		: function () {this.active = true;},
'LogOff'	: function () {this.active = false;},
'logLog'	: function (message, level) {
if (this.Data.active && this.Data.Levels[level].level <= this.Data.maximumLevel) {
if (this.Data.lineCount >= this.Data.maxLinesLogged) {
message = "Maximum number of log lines (=" + this.Data.maxLinesLogged + ") reached. Deactivating logging...";
this.Data.active = false;
level = 'Error'
}
var node = document.createElement("p");
node.setAttribute("class", this.Data.Levels[level].class);
node.innerHTML = this.Data.Levels[level].label + ": " + message;
this.Data.logContainer.insertBefore(node, this.Data.logContainer.firstChild);
console.log (node.innerHTML);
}
},
'logInfo'	: function (string) {this.logLog (string, 'Info');},
'logDebug'	: function (string) {this.logLog (string, 'Debug');},
'logWarn'	: function (string) {
this.logLog (string, 'Warn');
console.log ('Warning: ' + string);
},
'logError'	: function (string) {
this.logLog (string, 'Error');
console.log ('*** Error: ' + string);
},
}
var XSeen = (typeof(XSeen) === 'undefined') ? {} : XSeen;
XSeen.Convert = {
'fromString'	: function (v, t)
{
if (t == 'boolean') {
if (v == '' || v == 'f' || v == '0' || v == 'false') {return false;}
return true;
}
return v;
},
};
XSeen.onLoad = function() {
loadExternal = function(url, domElement) {
var xseenCode = '';
loadExternalSuccess = function (userdata) {
var e = userdata.e;
return function (response) {
console.log('Loading of external XSeen complete');
var parser = new DOMParser();
var xmlDoc = parser.parseFromString(response,"text/xml");
var rootNode = xmlDoc.getElementsByTagName('x-scene');
var nodes = rootNode[0].children;
while (nodes.length > 0) {
console.log('Adding external node: ' + nodes[0].nodeName);
e.appendChild(nodes[0]);
}
}
};
var loader = new THREE.FileLoader();
loader.load (url, 
loadExternalSuccess({'e':domElement}),
function ( xhr ) {
console.log('External source loader: ' + (xhr.loaded / xhr.total * 100) + '% loaded' );
},
function ( err ) {
console.log ('Response Code: ' + err.target.status);
console.log ('Response URL: ' + err.target.responseURL);
console.log ('Response Text\n' + err.target.responseText);
console.error( 'External source loader: An error happened' );
}
);
};
var sceneOccurrences, ii;
if (typeof(XSeen._Scenes) === 'undefined') {XSeen._Scenes = [];}
sceneOccurrences = document.getElementsByTagName (XSeen.Constants.tagPrefix + XSeen.Constants.rootTag);
for (ii=0; ii<sceneOccurrences.length; ii++) {
if (typeof(sceneOccurrences[ii]._xseen) === 'undefined') {
XSeen._Scenes.push(sceneOccurrences[ii]);
}
}
if (XSeen._Scenes.length < 1) {return;}
XSeen.Runtime.RootTag = XSeen._Scenes[0];
XSeen.Runtime.Attributes = [];
var allowedAttributes, defaultValues, value, attributeCharacteristics;
allowedAttributes = ['src', 'showlog', 'showstat', 'showprogress', 'cubetest'];
defaultValues = {'src':'', 'showlog':false, 'showstat':false, 'showprogress':false, 'cubetest':false};
attributeCharacteristics = {
'src'	: {
'name'		: 'src',
'default'	: '',
'type'		: 'string',
'case'		: 'sensitive' ,
},
'usecamera'	: {						// deprecated
'name'		: 'usecamera',
'default'	: 'false',
'type'		: 'boolean',
},
'showstat'	: {
'name'		: 'showstat',
'default'	: 'false',
'type'		: 'boolean',
'case'		: 'insensitive' ,
},
'showprogress'	: {
'name'		: 'showprogress',
'default'	: 'false',
'type'		: 'boolean',
'case'		: 'insensitive' ,
},
'transparent'	: {
'name'		: 'transparent',
'default'	: 'false',
'type'		: 'boolean',
'case'		: 'insensitive' ,
},
'fullscreen'	: {
'name'		: 'fullscreen',
'default'	: 'false',
'type'		: 'boolean',
'case'		: 'insensitive' ,
},
'cubetest'	: {
'name'		: 'cubetest',
'default'	: 'false',
'type'		: 'boolean',
'case'		: 'insensitive' ,
},
};
Object.getOwnPropertyNames(attributeCharacteristics).forEach (function (prop) {
value = XSeen.Runtime.RootTag.getAttribute(attributeCharacteristics[prop].name);
if (value == '' || value === null || typeof(value) === 'undefined') {value = attributeCharacteristics[prop].default;}
console.log ('Checking XSEEN attribute: ' + prop + '; with value: ' + value);
if (value != '') {
if (attributeCharacteristics[prop].case != 'sensitive') {
XSeen.Runtime.Attributes[attributeCharacteristics[prop].name] = XSeen.Convert.fromString (value.toLowerCase(), attributeCharacteristics[prop].type);
} else {
XSeen.Runtime.Attributes[attributeCharacteristics[prop].name] = XSeen.Convert.fromString (value, attributeCharacteristics[prop].type);
}
}
});
if (!(typeof(XSeen.Runtime.Attributes.src) == 'undefined' || XSeen.Runtime.Attributes.src == '')) {
console.log ('*** external SRC file specified ... |'+XSeen.Runtime.Attributes.src+'|');
loadExternal (XSeen.Runtime.Attributes.src, XSeen.Runtime.RootTag);
}
var Renderer;
if (XSeen.Runtime.Attributes.transparent) {
XSeen.Runtime.isTransparent = true;
} else {
XSeen.Runtime.isTransparent = false;
}
if (XSeen.Runtime.isTransparent) {
Renderer = new THREE.WebGLRenderer({'alpha':true,});		// Sets transparent WebGL canvas
console.log ('Creating a transparent rendering canvas.');
} else {
Renderer = new THREE.WebGLRenderer();
console.log ('Creating a opaque rendering canvas.');
}
XSeen.Runtime.RendererStandard	= Renderer;
XSeen.Runtime.RendererStereo	= new THREE.StereoEffect(Renderer);
XSeen.Runtime.Renderer			= XSeen.Runtime.RendererStandard;
Renderer = null;
XSeen.Logging = XSeen.definitions.Logging.init (XSeen.Runtime.Attributes['showlog'], XSeen.Runtime.RootTag);
XSeen.Runtime.Size = XSeen.updateDisplaySize (XSeen.Runtime.RootTag);	// TODO: test
XSeen.Runtime.Renderer.setSize (XSeen.Runtime.Size.width, XSeen.Runtime.Size.height);
XSeen.Runtime.Camera = XSeen.Runtime.ViewManager.create (XSeen.Runtime.Size.aspect);
XSeen.Runtime.SceneDom = XSeen.Runtime.Renderer.domElement;
XSeen.Runtime.RootTag.appendChild (XSeen.Runtime.SceneDom);
XSeen.Runtime.mediaAvailable = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);	// flag for device media availability
if (XSeen.Runtime.mediaAvailable && XSeen.Runtime.isTransparent) {
} else {
console.log ('Device Media support is not available or NOT requested ('+XSeen.Runtime.isTransparent+')');
}
if (navigator.getVRDisplays) {
navigator.getVRDisplays()
.then( function ( displays ) {
if ( displays.length > 0 ) {
XSeen.Runtime.isVrCapable = true;
} else {
XSeen.Runtime.isVrCapable = false;
}
} );
}
XSeen.Runtime.hasDeviceOrientation = (window.orientation) ? true : false;
XSeen.Runtime.hasVrImmersive = XSeen.Runtime.hasDeviceOrientation;
XSeen.LogInfo	= function (string) {XSeen.Logging.logInfo (string);}
XSeen.LogDebug	= function (string) {XSeen.Logging.logDebug (string);}
XSeen.LogWarn	= function (string) {XSeen.Logging.logWarn (string);}
XSeen.LogError	= function (string) {XSeen.Logging.logError (string);}
var defaultCamera = "<x-camera id='XSeen__DefaultCamera' position='0 0 10' type='perspective' track='orbit' priority='0' active='true' /></x-camera>";
var tmp = document.createElement('div');
tmp.innerHTML = defaultCamera;
XSeen.Runtime.RootTag.prepend (tmp.firstChild);
var splashScreen = '<img id="XSeen-Splash" src="https://XSeen.org/Resources/logo.svg" style="z-index:999; position:absolute; top:0; left:0; " width="'+XSeen.Runtime.Size.width+'">';
tmp.innerHTML = splashScreen;
XSeen.Runtime.RootTag.prepend (tmp.firstChild);
console.log ('Splash screen');
if (XSeen.Runtime.Attributes.fullscreen) {
var fs_button = XSeen.DisplayControl.buttonCreate ('fullscreen', XSeen.Runtime.RootTag, null);
var result = XSeen.Runtime.RootTag.appendChild (fs_button);
}
XSeen.Logging.logInfo ("XSeen version " + XSeen.Version.version + ", " + "Date " + XSeen.Version.date);
XSeen.LogInfo(XSeen.Version.splashText);
for (var ii=0; ii<XSeen.onLoadCallBack.length; ii++) {
XSeen.onLoadCallBack[ii]();
}
XSeen.Runtime.RootTag.addEventListener ('mouseover', XSeen.Events.xseen, true);
XSeen.Runtime.RootTag.addEventListener ('mouseout', XSeen.Events.xseen, true);
XSeen.Runtime.RootTag.addEventListener ('mousedown', XSeen.Events.xseen, true);
XSeen.Runtime.RootTag.addEventListener ('mouseup', XSeen.Events.xseen, true);
XSeen.Runtime.RootTag.addEventListener ('click', XSeen.Events.xseen, true);
XSeen.Runtime.RootTag.addEventListener ('dblclick', XSeen.Events.xseen, true);
var newEv = new CustomEvent('xseen-initialize', XSeen.Events.propertiesInitialize(XSeen.Runtime));
XSeen.Runtime.RootTag.dispatchEvent(newEv);
return;
}
XSeen.onLoadStartProcessing = function() {
if (typeof(XSeen.Runtime.RootTag._xseen) === 'undefined') {
XSeen.Runtime.RootTag._xseen = {					// Duplicated from Tag.js\%line202
'children'		: [],	// Children of this tag
'Metadata'		: [],	// Metadata for this tag
'tmp'			: [],	// tmp working space
'attributes'	: [],	// attributes for this tag
'animate'		: [],	// animatable attributes for this tag
'animation'		: [],	// array of animations on this tag
'properties'	: [],	// array of properties (active attribute values) on this tag
'class3d'		: [],	// 3D classes for this tag
'sceneInfo'		: XSeen.Runtime,	// Runtime data added to each tag
};
}
console.log ('Starting Parse...');
XSeen.Parser.Parse (XSeen.Runtime.RootTag, XSeen.Runtime.RootTag);
return;
};
XSeen.updateDisplaySize = function (sceneRoot) {
var MinimumValue = 50;
var size = Array();
size.width = sceneRoot.offsetWidth;
size.height = Math.floor(sceneRoot.offsetHeight -5);	// Firefox requires 5 less for an unknown reason
if (size.width < MinimumValue) {
var t = sceneRoot.getAttribute('width');
if (t < MinimumValue) {t = MinimumValue;}
size.width = t;
}
if (size.height < MinimumValue) {
var t = sceneRoot.getAttribute('height');
if (t < MinimumValue) {t = MinimumValue;}
size.height = t;
}
size.iwidth = 1.0 / size.width;
size.iheight = 1.0 / size.height;
size.aspect = size.width * size.iheight;
console.log ('Display size: ' + size.width + ' x ' + size.height);
return size;
}
var XSeen = XSeen || {};
XSeen.Tags = {
'_setSpace'		: function (object, spaceAttributes) {
if (object.isObject3D) {
if (typeof(spaceAttributes.position) !== 'undefined') {
object.position.x = spaceAttributes.position.x;
object.position.y = spaceAttributes.position.y;
object.position.z = spaceAttributes.position.z;
}
if (typeof(spaceAttributes.rotation) !== 'undefined') {
object.setRotationFromQuaternion (spaceAttributes.rotation);
}
if (typeof(spaceAttributes.scale) !== 'undefined') {
object.scale.x = spaceAttributes.scale.x;
object.scale.y = spaceAttributes.scale.y;
object.scale.z = spaceAttributes.scale.z;
}
}
},
};
XSeen.Parser = {
'Table'		: {},
'_prefix'	: 'x-',
'AttributeObserver'	: new MutationObserver(function(list) {
for (var mutation of list) {
var value = XSeen.Parser.reparseAttr (mutation.target, mutation.attributeName);
var localName = mutation.target.localName;
var handler = XSeen.Parser.Table[localName].eventHandlers.mutation.handler;
handler (mutation.target, mutation.attributeName, value);
}
}),
'ChildObserver'	: new MutationObserver(function(list) {
for (var mutation of list) {
console.log ('Child mutation element');
mutation.addedNodes[0]._xseen = {
'children'              : [],   // Children of this tag
'Metadata'              : [],   // Metadata for this tag
'tmp'                   : [],   // tmp working space
'attributes'    : [],   // attributes for this tag
'animate'               : [],   // animatable attributes for this tag
'animation'             : [],   // array of animations on this tag
'properties'    : [],   // array of properties (active attribute values) on this tag
'class3d'               : [],   // 3D classes for this tag
'parseComplete' : false,        // tag has been completely parsed
'sceneInfo'             : mutation.target._xseen.sceneInfo,     // Runtime...
};
XSeen.Parser.Parse (mutation.addedNodes[0], mutation.target);
if (mutation.target.localName == 'x-scene') {
XSeen.Tags.scene.addScene();		// Not the most elegant way to do this... :-(
XSeen.Runtime.ViewManager.setNext();	// Update the camera
}
}
}),
'TypeInfo'		: {
'string'	: {'isNumeric':false, 'arrayAllowed':false, parseElements:false, numElements:1, },
'boolean'	: {'isNumeric':false, 'arrayAllowed':false, parseElements:false, numElements:1, },
'integer'	: {'isNumeric':false, 'arrayAllowed':true, parseElements:true, numElements:1, },
'color'		: {'isNumeric':true, 'arrayAllowed':false, parseElements:true, numElements:-1, },
'float'		: {'isNumeric':true, 'arrayAllowed':true, parseElements:true, numElements:1, },
'vec2'		: {'isNumeric':true, 'arrayAllowed':true, parseElements:true, numElements:2, },
'vec3'		: {'isNumeric':true, 'arrayAllowed':true, parseElements:true, numElements:3, },
'xyz'		: {'isNumeric':true, 'arrayAllowed':true, parseElements:true, numElements:3, },
'vec4'		: {'isNumeric':true, 'arrayAllowed':true, parseElements:true, numElements:4, },
'rotation'	: {'isNumeric':true, 'arrayAllowed':false, parseElements:true, numElements:-1, },
'vector'	: {'isNumeric':true, 'arrayAllowed':true, parseElements:true, numElements:0, },
},
'defineTag' : function (tagObj, init, fin, events)
{
if (arguments.length != 1) {
tagObj = {
'name'		: tagObj,
'init'		: init,
'fin'		: fin,
'events'	: events};		// Removed 'tick'
}
var tag = {
'tag'			: XSeen.Parser._prefix + tagObj.name.toLowerCase(),
'init'			: tagObj.init,
'fin'			: tagObj.fin,
'events'		: tagObj.events,
'attributes'	: [],
'attrIndex'		: [],
'eventHandlers'	: [],
'addSceneSpace'	: function ()
{
var v = this
.defineAttribute ({'name':'position', dataType:'xyz', 'defaultValue':{x:0, y:0, z:0}})
.defineAttribute ({'name':'rotation', dataType:'rotation', 'defaultValue':[0,0,0]})
.defineAttribute ({'name':'rotate-x', dataType:'float', 'defaultValue':0})
.defineAttribute ({'name':'rotate-y', dataType:'float', 'defaultValue':0})
.defineAttribute ({'name':'rotate-z', dataType:'float', 'defaultValue':0})
.defineAttribute ({'name':'scale', dataType:'xyz', 'defaultValue':{x:1, y:1, z:1}});
return v;
},
'defineAttribute'	: function (attrObj, dataType, defaultValue)
{
if (arguments.length != 1) {
attrObj = {
'name'				: attrObj,
'dataType'			: dataType,
'defaultValue'		: defaultValue,
'isCaseInsensitive'	: true,
'isAnimatable'		: null,
'enumeration'		: [],
'isArray'			: false,
};
}
if (typeof(attrObj.isAnimatable) == 'undefined') {
attrObj.isAnimatable = (XSeen.Parser.TypeInfo[attrObj.dataType].isNumeric) ? true : false;
}
if (typeof(attrObj.elementCount) == 'undefined') {
attrObj.elementCount = XSeen.Parser.TypeInfo[attrObj.dataType].numElements;
} else {
attrObj.elementCount = Math.max (XSeen.Parser.TypeInfo[attrObj.dataType].numElements, attrObj.elementCount);
}
var name = attrObj.name.toLowerCase();
attrObj.enumeration = (typeof(attrObj.enumeration) == 'object') ? attrObj.enumeration : [];
attrObj.isCaseInsensitive = (typeof(attrObj.isCaseInsensitive) !== 'undefined') ? attrObj.isCaseInsensitive : false;
if (attrObj.dataType != 'string') {
attrObj.isCaseInsensitive = true;
} else {
attrObj.isArray = false;
}
this.attributes.push ({
'attribute'			: name,
'type'				: attrObj.dataType,
'default'			: attrObj.defaultValue,
'enumeration'		: attrObj.enumeration,
'elementCount'		: attrObj.elementCount,
'isCaseInsensitive'	: attrObj.isCaseInsensitive,
'isAnimatable'		: (typeof(attrObj.isAnimatable) !== null) ? attrObj.isAnimatable : false,
'isEnumerated'		: (attrObj.enumeration.length == 0) ? false : true,
'isArray'			: (typeof(attrObj.isArray) !== null) ? attrObj.isArray : false,
'clone'				: this.cloneAttribute,
'setAttrName'		: this.setAttrName,
});
this.attributes[name] = this.attributes[this.attributes.length-1];
this.attrIndex[name] = this.attributes.length-1;
return this;
},
'addEvents'	: function (handlerObj)
{
if (typeof(handlerObj.mutation) !== 'unknown' && typeof(handlerObj.mutation[0].attributes) !== 'unknown') {
this.eventHandlers['mutation'] = {
'options'	: {'attributes':true},
'handler'	: handlerObj.mutation[0].attributes,
};
}
return this;
},
'addTag'	: function () {
XSeen.Parser.Table[this.tag] = this;
},
'cloneAttribute'	: function () {
var newAttrObject = {
'attribute'			: this.name,
'type'				: this.type,
'default'			: this.default,
'enumeration'		: [],
'isCaseInsensitive'	: this.isCaseInsensitive,
'isAnimatable'		: this.isAnimatable,
'isEnumerated'		: this.isEnumerated,
'isArray'			: this.isArray,
'clone'				: this.clone,
'setAttrName'		: this.setAttrName,
};
for (var i=0; i<this.enumeration.length; i++) {
newAttrObject.enumeration.push(this.enumeration[i]);
}
if (Array.isArray(this.default)) {
newAttrObject.default = [];
for (var i=0; i<this.default.length; i++) {
newAttrObject.default.push(this.default[i]);
}
}
return newAttrObject;
},
'setAttrName'	: function(newName) {
this.attribute = newName;
return this;
},
};
return tag;
},
'getTag' : function (tagName)
{
if (typeof(tagName) == 'undefined' || tagName == '') {return null;}
var tag = XSeen.Parser._prefix + tagName;
if (typeof(XSeen.Parser.Table[tag]) == 'undefined') {return null;}
return XSeen.Parser.Table[tag];
},
'Parse'	: function (element, parent)
{
var tagName = element.localName.toLowerCase();		// Convenience declaration
console.log ('Found ' + tagName);
var tagEntry;
if (typeof(XSeen.Parser.Table[tagName]) == 'undefined') {
XSeen.LogDebug("Unknown node: " + tagName + '. Skipping all children.');
console.log ("DEBUG: Unknown node: " + tagName + '. Skipping all children.');
return;
} else if (element._xseen.parseComplete) {	// tag already parsed. Display messge and ignore tag
XSeen.LogDebug("Tag already parsed: " + tagName + '. Skipping all children.');
console.log ("DEBUG: Tag already parsed: " + tagName + '. Skipping all children.');
} else {
tagEntry = XSeen.Parser.Table[tagName];
if (typeof(element._xseen) == 'undefined') {
element._xseen = {
'children'		: [],	// Children of this tag
'Metadata'		: [],	// Metadata for this tag
'tmp'			: [],	// tmp working space
'attributes'	: [],	// attributes for this tag
'animate'		: [],	// animatable attributes for this tag
'animation'		: [],	// array of animations on this tag
'properties'	: [],	// array of properties (active attribute values) on this tag
'class3d'		: [],	// 3D classes for this tag
'parseComplete'	: false,	// tag has benn completely parsed
};
}
XSeen.Parser.ChildObserver.observe (element, {'childList':true});
this.parseAttrs (element, tagEntry);
XSeen.LogInfo('Calling node: ' + tagName + '. Method: init');
tagEntry.init (element, parent);
}
for (element._xseen.parsingCount=0; element._xseen.parsingCount<element.childElementCount; element._xseen.parsingCount++) {
element.children[element._xseen.parsingCount]._xseen = {
'children'		: [],	// Children of this tag
'Metadata'		: [],	// Metadata for this tag
'tmp'			: [],	// tmp working space
'attributes'	: [],	// attributes for this tag
'animate'		: [],	// animatable attributes for this tag
'animation'		: [],	// array of animations on this tag
'properties'	: [],	// array of properties (active attribute values) on this tag
'class3d'		: [],	// 3D classes for this tag
'parseComplete'	: false,	// tag has been completely parsed
'sceneInfo'		: element._xseen.sceneInfo,	// Runtime...
};
this.Parse (element.children[element._xseen.parsingCount], element);
}
if (typeof(tagEntry) !== 'undefined') {
element.addEventListener ('XSeen', tagEntry.events);
tagEntry.fin (element, parent);
if (typeof(element._xseen.tmp.meta) !== 'undefined' && element._xseen.tmp.meta.length != 0) {
element._xseen.Metadata = element._xseen.tmp.meta;
element._xseen.tmp.meta = [];
}
if (typeof(tagEntry.eventHandlers.mutation) !== 'undefined') {
XSeen.Parser.AttributeObserver.observe (element, tagEntry.eventHandlers.mutation.options);
}
element._xseen.parseComplete = true;
}
},
'parseAttrs'	: function (element, tagObj)
{
element._xseen.parseAll = false;
var classt = element.getAttribute('class3d');					// Get list of class3d (really IDs)
var classes3d = (classt === null) ? [] : classt.split(' ');		// and split it (if defined)
for (var ii=0; ii<classes3d.length; ii++) {						// Attaching all referenced class definitions to tag
element._xseen.class3d.push (element._xseen.sceneInfo.StyleRules.idLookup[classes3d[ii]]);
}
tagObj.attributes.forEach (function (attr, ndx, wholeThing)
{
var value = this.parseAttr (attr, element, element._xseen.class3d);
if (value == 'XSeen.parse.all') {
element._xseen.parseAll = true;
} else {
element._xseen.attributes[attr.attribute] = value;
if (attr.isAnimatable) {element._xseen.animate[attr.attribute] = null;}
}
}, this);
},
'reparseAttr'	: function (ele, attributeName)
{
if (typeof(XSeen.Parser.Table[ele.localName]) === 'undefined') {return null;}
var tagObj = XSeen.Parser.Table[ele.localName];
if (typeof(tagObj.attributes[attributeName]) === 'undefined') {return null; }
var attr = tagObj.attributes[attributeName];
var value = XSeen.Parser.parseAttr (attr, ele, ele._xseen.class3d);
return value;
},
'parseAttr'		: function (attr, ele, class3d)			// Parse an individual attribute
{
var classValue = this.getClassAttributeValue (attr.attribute, class3d)
var value = ele.getAttribute(attr.attribute);
if (value === null || value == '') {value = classValue;}
if (attr.isArray) {
if (!XSeen.Parser.TypeInfo[attr.type].arrayAllowed || attr.elementCount < 1) {
if (value == '') {value = attr.default;}
return value;
}
if (typeof(value) == 'undefined' || value === null || value.length == 0) {return value; }
valueArray = XSeen.Parser.parseArrayValue (value, attr.elementCount, attr.type, attr.default);
return valueArray;
} else {
value = XSeen.Parser.Types[attr.type] (value, attr.default, attr.caseInsensitive, attr.enumeration);
}
return value;
},
'getClassAttributeValue' : function (attribute, classList)
{
var classValue = null;
if (classList === null) {return classValue;}
for (var ii=0; ii<classList.length; ii++) {
for (var jj=0; jj<classList[ii].declaration.length; jj++) {
if (classList[ii].declaration[jj].property == attribute) {
classValue = classList[ii].declaration[jj].value;
}
}
}
return classValue;
},
'parseArrayValue'	: function (attrValue, elementCount, attrType, attrDefault)
{
function getElementsFromArray (ea, ndx, increment) {
var ev = [];
for (var ii=ndx; ii<ndx+increment; ii++) {
ev.push(ea[ii]);
}
return ev;
}
var elementArray = XSeen.Parser.Types._elementSplit (attrValue);
var numElements = XSeen.Parser.TypeInfo[attrType].numElements;
var collectionCount = elementCount / numElements;
var totalElements = elementArray.length;
var ndx = 0;
var valueArray=[], elementValues=[], tmp;
while (ndx < totalElements) {
tmp = [];
for (var jj=0; jj<collectionCount; jj++) {
elementValues = getElementsFromArray (elementArray, ndx, numElements);
ndx += numElements;
tmp.push (XSeen.Parser.Types[attrType](elementValues, attrDefault, false, ''));
}
if (collectionCount == 1) {
valueArray.push (tmp[0]);
} else {
valueArray.push (tmp);
}
}
return valueArray;
},
'getAttrInfo' : function (tagName, attrName) {
var attrInfo = {'good': false, 'tagExists': false, 'attrExists': false};
if (typeof(tagName) === 'undefined' || tagName == '' || typeof(attrName) === 'undefined' || attrName == '') {return attrInfo;}
var tagName = tagName.toLowerCase();
if (typeof(XSeen.Parser.Table[tagName]) === 'undefined') {
return attrInfo;
}		// TODO: Need to convert all following from node => tag; field => attribute; and use new structures
attrInfo.tagExists = true;
var tag = XSeen.Parser.Table[tagName];
var attrName = attrName.toLowerCase();
if (typeof(tag.attrIndex[attrName]) === 'undefined') {
return attrInfo;
}
attrInfo.attrExists = true;
var attribute = tag.attributes[tag.attrIndex[attrName]];
attrInfo.tag			= tag;
attrInfo.attribute		= attribute;
attrInfo.handlerName	= tag.event;
attrInfo.dataType		= attribute.type;
attrInfo.default		= attribute.default;
attrInfo.elementCount	= attribute.elementCount;
attrInfo.good = true;
return attrInfo;
},
'dumpTable'	: function ()
{
var jsonstr = JSON.stringify ({'tags': XSeen.Parser.Table}, null, '  ');
console.log('Node parsing table (' + XSeen.Parser.Table.length + ' tags)\n' + jsonstr);
return jsonstr;
},
'loadTable'	: function (jsonstr)
{
var jsonstr = JSON.stringify ({'tags': XSeen.Parser.Table}, null, '  ');
XSeen.Parser.Table = [];
},
'Types'	: {
'_checkEnumeration'	: function (value, def, enumeration)
{
for (var ii=0; ii<enumeration.length; ii++) {
if (value == enumeration[ii]) {return value;}
}
if (enumeration.length == 0) {return value;}
return def;
},
'_elementSplit'	: function(string) 
{
myRe = /[\s,\(\[\]\)]+/;
return string.replace(/^[\s,\(\[\]\)]+|[\s,\(\[\]\)]+$/g, '').split (myRe);
},
'_splitArray'	: function (value, def, minCount)
{
if (typeof(value) == 'object') {
return (value.length < minCount) ? def : value;
}
var arrayValue = value.split(' ');
if (arrayValue.length < minCount) {return def;}
return arrayValue;
},
'string'	: function(value, def, insensitive, enumeration) 
{
if (insensitive) {value = value.toLowerCase();}
if (value === null) {return def;}
return this._checkEnumeration (value, def, enumeration);
},
'integer'	: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
if (Number.isNaN(value)) {return def};
return Math.round(this._checkEnumeration (value, def, enumeration));
},
'float'		: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
if (Number.isNaN(value)) {return def};
return this._checkEnumeration (value, def, enumeration)-0;
},
'vec2'		: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
var arrayValue = this._splitArray (value, def, 2);
var retValue = [this.float(arrayValue[0], def[0], false, []),
this.float(arrayValue[1], def[1], false, [])];
return retValue;
},
'vec3'		: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
var arrayValue = this._splitArray (value, def, 3);
var retValue = [this.float(arrayValue[0], def[0], false, []),
this.float(arrayValue[1], def[1], false, []),
this.float(arrayValue[2], def[2], false, [])];
return retValue;
},
'xyz'		: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
var arrayValue = this._splitArray (value, def, 3);
var retValue = {x:this.float(arrayValue[0], def[0], false, []),
y:this.float(arrayValue[1], def[1], false, []),
z:this.float(arrayValue[2], def[2], false, [])};
return retValue;
},
'vec4'		: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
var arrayValue = this._splitArray (value, def, 4);
var retValue = [this.float(arrayValue[0], def[0], false, []),
this.float(arrayValue[1], def[1], false, []),
this.float(arrayValue[2], def[2], false, []),
this.float(arrayValue[3], def[3], false, [])];
return retValue;
},
'vector'	: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
var arrayValue = this._splitArray (value, def);
return arrayValue;
},
'boolean'	: function(value, def, insensitive, enumeration)
{
if (value === null) return def;
if (value === '') return def;
var svalue = value.toLowerCase();
if (svalue == '') return def;
if (svalue == 'f' || svalue == 'false' || svalue == '0') return false;
var ivalue = Boolean (value);
return ivalue;
},
'vecToFloat3'	: function (value, def)
{
var retValue = [
this.float(value[0], def[0], false, []),
this.float(value[1], def[1], false, []),
this.float(value[2], def[2], false, []),
];
return retValue;
},
'vecToXYZ'	: function (value, def)
{
var retValue = {
'x':this.float(value[0], def.x, false, []),
'y':this.float(value[1], def.y, false, []),
'z':this.float(value[2], def.z, false, []),
};
return retValue;
},
'rotation2Quat'	: function (value)		// Converts axis-angle (vec4) to quaternion
{
var quat = new THREE.Quaternion();
quat.setFromAxisAngle (new THREE.Vector3(value[0], value[1], value[2]), value[3]);
return quat;
},
'color'	: function(value, def, insensitive, enumeration)
{
if (value === null) {return def;}
value = value.trim().toLowerCase();
if (!Number.isNaN(value) && Math.round(value) == value && (value-0 <= 16777215) && (value-0 >= 0)) {return this.colorIntRgb(value);}
if (value.substring(0,1) == '#') {
value = '0x' + value.substring(1,value.length) - 0;
if (Number.isNaN(value) || value < 0 || value > 16777215) {return def;}
return this.colorIntRgb(value);
}
if (value.substring(0,3) == 'rgb') {
XSeen.LogWarn("RGB[A] color not yet implemented");
console.log ("WARN: RGB[A] color not yet implemented");
}
if (value.substring(0,3) == 'hsl') {
XSeen.LogWarn("HSL[A] color not yet implemented");
console.log ("WARN: HSL[A] color not yet implemented");
}
if (value.substring(0,3) == 'f3(') {
XSeen.LogWarn("HSL[A] color not yet implemented");
console.log ("WARN: HSL[A] color not yet implemented");
if (value.substring(value.length-1,value.length) != ')') {
XSeen.LogWarn ("WARN: Illegal syntax for f3 color -- no closing ')'");
console.log ("WARN: Illegal syntax for f3 color -- no closing ')'");
} else {
var colorString = value.substring(3,value.length-1);
var colors = colorString.split(' ');
return {'r':colors[0], 'g':colors[1], 'b':colors[2]};
}
}
if (value.substring(0,3) == 'f4(') {
XSeen.LogWarn("F4 color not yet implemented");
console.log ("WARN: F4 color not yet implemented");
}
if (typeof(XSeen.CONST.Colors[value]) === 'undefined') {return def;}
return this.colorIntRgb(XSeen.CONST.Colors[value]);	// TODO: add check on enumeration
},
'colorIntRgb' : function (colorInt)
{
var r = (colorInt & 0xff0000) >>> 16;
var g = (colorInt & 0x00ff00) >>> 8;
var b = (colorInt & 0x0000ff);
return {'r':r/255., 'g':g/255., 'b':b/255.};
},
'colorRgbInt' : function (color)
{
if (typeof (color) !== 'object') return 0;
var colorInt =	(Math.round(color.r*255) << 16) |
(Math.round(color.g*255) << 8) |
(Math.round(color.b*255));
return colorInt;
},
'rotation'	: function(value, def, insensitive, enumeration)
{
if (value === null) {value = def;}
if (value == '') {value = def;}
var eulerAngles, processed = false;
var quat = new THREE.Quaternion();
if (typeof(value) == 'string') {
if (value.substring(0,2) == 'h(') {
processed = true;
value = value.substring(2,value.length-1);
var axisAngle = this.vec4 (value, def, true, [0, 1, 0, 0]);
quat = this.rotation2Quat (axisAngle);
} else if (value.substring(0,2) == 'q(') {
console.log ('No support yet for quaternion form of rotation');
value = def;
eulerAngles = this.vec3 (value, def, true, []);
} else if (value.substring(0,2) == 'e(') {
value = value.substring(2,value.length-1);
eulerAngles = this.vec3 (value, def, true, []);
} else {
eulerAngles = this.vec3 (value, def, true, []);
}
} else {
eulerAngles = value;
}
if (!processed) {
var euler = new THREE.Euler();
euler.fromArray (eulerAngles);
quat.setFromEuler (euler);
}
return quat;
},
},		// End of 'Types' object
};
XSeen = (typeof(XSeen) === 'undefined') ? {} : XSeen;
XSeen.Constants = {
'_Major'		: 0,
'_Minor'		: 7,
'_Patch'		: 41,
'_PreRelease'	: '',
'_Release'		: 7,
'_Version'		: '',
'_RDate'		: '2018-11-08',
'_SplashText'	: ["XSeen 3D Language parser.", "XSeen <a href='https://xseen.org/index.php/documentation/' target='_blank'>Documentation</a>."],
'tagPrefix'		: 'x-',
'rootTag'		: 'scene',
};
XSeen.CONST = XSeen.DefineConstants();
XSeen.Time =  {
'start'		: (new Date()).getTime(),
'now'		: (new Date()).getTime(),
};
XSeen.Version = {
'major'			: XSeen.Constants._Major,
'minor'			: XSeen.Constants._Minor,
'patch'			: XSeen.Constants._Patch,
'preRelease'	: XSeen.Constants._PreRelease,
'release'		: XSeen.Constants._Release,
'version'		: XSeen.Constants._Major + '.' + XSeen.Constants._Minor + '.' + XSeen.Constants._Patch,
'date'			: XSeen.Constants._RDate,
'splashText'	: XSeen.Constants._SplashText,
};
XSeen.Version.version += (XSeen.Version.preRelease != '') ? '-' + XSeen.Version.preRelease : '';
XSeen.Version.version += (XSeen.Version.release != '') ? '+' + XSeen.Version.release : '';
if (typeof(XSeen.onLoadCallBack) === 'undefined') {
XSeen.onLoadCallBack = [];
}
XSeen.parseTable = [];
XSeen.Runtime = {
'currentTime'			: 0,			// Current time at start of frame rendering
'deltaTime'				: 0,			// Time since last frame
'frameNumber'			: 0,			// Number of frame about to be rendered
'Time'					: new THREE.Clock(),
'Renderer'				: {},			// Active renderer in current use.
'RendererStandard'		: {},			// One of these two renderers are used. 'onLoad' declares 
'RendererStereo'		: {},			// these and 'camera' chooses which one
'Camera'				: {},			// Current camera in use
'CameraControl'			: {},			// Camera control to be used in Renderer for various types
'DefinedCameras'		: [],			// Array of defined cameras
'ViewManager'			: XSeen.CameraManager,
'Mixers'				: [],			// Internal animation mixer array
'perFrame'				: [],			// List of methods with data to execute per frame
'Animate'				: function() {	// XSeen animation loop control
if (XSeen.Runtime.isStereographic) {
requestAnimationFrame (XSeen.Runtime.Animate);
XSeen.RenderFrame();
} else {
XSeen.Runtime.Renderer.animate (XSeen.RenderFrame);
}
},
'TweenGroups'			: [],
'Resize'				: function () {
if (!XSeen.Runtime.isStereographic) {
XSeen.Runtime.Size = XSeen.updateDisplaySize (XSeen.Runtime.RootTag);
XSeen.Runtime.Camera.aspect = XSeen.Runtime.Size.width / XSeen.Runtime.Size.height;
XSeen.Runtime.Camera.updateProjectionMatrix();
XSeen.Runtime.Renderer.setSize (XSeen.Runtime.Size.width, XSeen.Runtime.Size.height)
}
},
'rulesets'				: [],			// Style ruleset array structure
'StyleRules'			: {				// Collection of style rulesets
'ruleset'	: [],					// Specific ruleset
'idLookup'	: []	},				// Cross-reference into 'rulesets' by 'id'
'selectable'			: [],			// Selectable geometry elements
'isVrCapable'			: false,		// WebVR ready to run && access to VR device 
'hasDeviceOrientation'	: false,		// device has Orientation sensor
'hasVrImmersive'		: false,		// hasDeviceOrientation && stereographic capable (=== TRUE)
'useDeviceOrientation'	: false,		// display is using device's Orientation sensor
'isStereographic'		: false,		// currently running stereographic display (not VR)
'rendererHasControls'	: false,		// Renderer has built-in motion controls
'isProcessingResize'	: false,		// semaphore for resizing processing
'mediaAvailable'		: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),	// flag for device media availability
'isTransparent'			: false,		// flag for XSeen transparent background
};										// Need place-holder for xR scene (if any -- tbd)
XSeen.RenderFrame = function()
{
if (XSeen.Runtime.isProcessingResize) {return;}		// Only do one thing at a time
if (XSeen.Runtime.frameNumber == 0) {		// TODO: Replace with 'dirty' flag. May not need loadingComplete
if (XSeen.Loader.loadingComplete()) {	//	Code needs to set Runtime.nodeChange whenever nodes are added/removed
XSeen.Tags.scene.addScene();
document.getElementById('XSeen-Splash').style.display = 'none';
console.log ('***Rendering first frame');
} else {
return;
}
}
XSeen.Runtime.deltaTime = XSeen.Runtime.Time.getDelta();
XSeen.Runtime.currentTime = XSeen.Runtime.Time.getElapsedTime();
XSeen.Runtime.frameNumber ++;
var newEv = new CustomEvent('xseen-render', XSeen.Events.propertiesRenderFrame(XSeen.Runtime));
XSeen.Runtime.RootTag.dispatchEvent(newEv);
XSeen.Update.Camera (XSeen.Runtime);
XSeen.Update.Mixers (XSeen.Runtime);
XSeen.Update.Tween (XSeen.Runtime);
if (XSeen.Runtime.frameNumber > 1) XSeen.Update.Ticks (XSeen.Runtime);
XSeen.Runtime.Renderer.render( XSeen.Runtime.SCENE, XSeen.Runtime.Camera );
};
XSeen.Update = {
'Tween'		: function (Runtime)
{
TWEEN.update();
if (typeof(Runtime.TweenGroups) != 'undefined') {
for (var ii=0; ii<Runtime.TweenGroups.length; ii++) {
Runtime.TweenGroups[ii].update();
}
}
},
'Mixers'	: function (Runtime)
{
if (typeof(Runtime.Mixers) === 'undefined') return;
for (var i=0; i<Runtime.Mixers.length; i++) {
Runtime.Mixers[i].update(Runtime.deltaTime);
}
},
'Ticks'		: function (Runtime)
{
for (var i=0; i<Runtime.perFrame.length; i++) {
Runtime.perFrame[i].method (Runtime, Runtime.perFrame[i].userdata);
}
},
'Camera'	: function (Runtime)
{
if (!Runtime.rendererHasControls) {
Runtime.CameraControl.update();
}
},
}
window.document.addEventListener('DOMContentLoaded', XSeen.onLoad);
window.document.addEventListener('xseen-initialize', XSeen.onLoadStartProcessing);
XSeen.Tags.animate = {
'cnv'	: {		/* Insures that the correct case is used */
'style' : {'in':'In', 'out':'Out', 'inout': 'InOut'},
'type': {'linear':'Linear', 'quadratic':'Quadratic', 'sinusoidal':'Sinusoidal', 'exponential':'Exponential', 'elastic':'Elastic', 'bounce':'Bounce'},
},
'_easeCheck' : function (direction, type, store)
{
direction = (type != 'linear' && direction == '') ? 'inout' : direction;
if (direction != '') {
type = (type == 'linear') ? 'quadratic' : type;
direction = XSeen.Tags.animate.cnv.style[direction];
type = XSeen.Tags.animate.cnv.type[type];
} else {
direction = 'None';
type = 'Linear';
}
store.easing = direction;
store.easingtype = type;
},
_getTo: function (e, attrObject, toAttribute)
{
var to, interpolation, startingValue;
to = XSeen.Parser.parseAttr(attrObject, e, []);	// Parsed data  -- need to convert to THREE format
if (attrObject.type == 'float') {
interpolation = TWEEN.Interpolation.Linear;
to = XSeen.Parser.Types.float(to, 0.0, false, []);
startingValue = 0;	// TODO: Only should be 0 if cannot get value from object
XSeen.LogInfo("Interpolating field '" + toAttribute + "' as float.");
} else if (attrObject.type == 'vec3') {
interpolation = TWEEN.Interpolation.Linear;
to = XSeen.Parser.Types.vecToXYZ(to, {'x':0,'y':0,'z':0});
XSeen.LogInfo("Interpolating field '" + toAttribute + "' as 3-space.");
} else if (attrObject.type == 'xyz') {				// No parsing necessary
interpolation = TWEEN.Interpolation.Linear;
XSeen.LogInfo("Interpolating field '" + toAttribute + "' as 3-space (no parse).");
} else if (attrObject.type == 'color') {
interpolation = XSeen.Tags.animate.Interpolator.color;
if (typeof(to) == 'string') {to = new THREE.Color (XSeen.Parser.Types.color(to));}
XSeen.LogInfo("Interpolation field '" + toAttribute + "' as color.");
} else if (attrObject.type == 'vec4' || attrObject.type == 'rotation') {
interpolation = XSeen.Tags.animate.Interpolator.slerp;
XSeen.LogInfo("Interpolation field '" + toAttribute + "' as rotation.");
} else {
XSeen.LogInfo("Field '" + toAttribute + "' not converted to THREE format. No animation performed.");
return {'to':null, 'interpolation':null};
}
return {'to':to, 'interpolation':interpolation};
},
'init'	: function (e,p) 
{
if (e._xseen.attributes.duration > 0) {
e._xseen.keyFraction = true;
} else {
e._xseen.keyFraction = false;
e._xseen.attributes.duration = 0;
}
XSeen.Tags.animate._easeCheck (e._xseen.attributes.easing, e._xseen.attributes.easingtype, e._xseen.attributes);
e._xseen.key = [];
var toAttribute = e._xseen.attributes.attribute;
var attributes = XSeen.Parser.Table[p.localName.toLowerCase()].attributes;
e._xseen.attrObject = attributes[toAttribute].clone().setAttrName('to');	// Parse table entry for 'toAttribute'
e._xseen.tagObject = new TWEEN.Group();
},
'fin'	: function (e,p)
{
console.log ('Check e._xseen.key for correct values');
var duration = e._xseen.attributes.duration * 1000;	// TEMP: Convert to milliseconds
var delay = e._xseen.attributes.delay * 1000;		// Convert to milliseconds
var yoyo = e._xseen.attributes.yoyo;
var repeat = (e._xseen.attributes.repeat < 0) ? Infinity : e._xseen.attributes.repeat;
var interpolation, startingValue;
var attrObject = e._xseen.attrObject;
var toAttribute = e._xseen.attributes.attribute;
console.log ('Check for keyframes ... count: ' + e._xseen.key.length);
if (e._xseen.key.length == 0) {		// Block handles no key frames
var target = XSeen.Tags.animate._getTo (e, e._xseen.attrObject, e._xseen.attributes.attribute);
if (target.to === null) {return; }
var fieldTHREE, useUpdate, tween, startingValue;
if (typeof(p._xseen.animate[toAttribute]) == 'function') { 
fieldTHREE = p._xseen.attributes[toAttribute];		// THREE field for animation
var setter = {'from':fieldTHREE, 'current':fieldTHREE, 'attribute':toAttribute};
useUpdate = true;
tween = new TWEEN.Tween (setter, e._xseen.tagObject)
.to({'current':target.to}, duration)
.onUpdate(p._xseen.animate[toAttribute]);
startingValue = fieldTHREE;
} else {
fieldTHREE = p._xseen.animate[toAttribute];			// THREE field for animation
useUpdate = false;
tween = new TWEEN.Tween(fieldTHREE, e._xseen.tagObject).to(target.to, duration);
startingValue = fieldTHREE.clone();
}
e._xseen.initialValue = startingValue;
tween	.delay(delay)
.repeat(repeat)
.interpolation(target.interpolation)
.yoyo(yoyo);
var easingType = e._xseen.attributes.easingtype;
var easing = e._xseen.attributes.easing;
if (easing != '') {
tween.easing(TWEEN.Easing[easingType][easing]);
}
e._xseen.animating = tween;
p._xseen.animation.push (tween);
e._xseen.sceneInfo.TweenGroups.push (e._xseen.tagObject);
tween.start();
} else {
var fieldTHREE = p._xseen.animate[toAttribute];			// THREE field for animation
var startingValue = fieldTHREE.clone();
e._xseen.initialValue = startingValue;
var tween0, tweenP, tween;
tween0 = new TWEEN.Tween(fieldTHREE, e._xseen.tagObject);
tween0	.to(e._xseen.key[0].to, duration)
.delay(delay)
.interpolation(e._xseen.key[0].interpolation)
.easing(TWEEN.Easing[e._xseen.key[0].easingType][e._xseen.key[0].easing]);
tweenP = tween0;
for (var ii=1; ii<e._xseen.key.length; ii++) {
tween = new TWEEN.Tween(fieldTHREE, e._xseen.tagObject);
tween	.to(e._xseen.key[ii].to, duration)
.delay(delay)
.interpolation(e._xseen.key[ii].interpolation)
.easing(TWEEN.Easing[e._xseen.key[ii].easingType][e._xseen.key[ii].easing]);
tweenP.chain(tween);
tweenP = tween;
}
if (repeat === Infinity) {
console.log ('test');
tween.chain(tween0);
}
tween0.start();
e._xseen.animating = e._xseen.tagObject;
p._xseen.animation.push (e._xseen.tagObject);
e._xseen.sceneInfo.TweenGroups.push (e._xseen.tagObject);
}
console.log ('Close up shop for animate...');
e._xseen.handlers = {};
e._xseen.handlers.setstart = XSeen.Tags.animate.setstart;
e._xseen.handlers.setstop = XSeen.Tags.animate.setstop;
e._xseen.handlers.setpause = XSeen.Tags.animate.setpause;
e._xseen.handlers.setresetstart = XSeen.Tags.animate.setresetstart;
},
'event'	: function (ev, attr)
{
console.log ('Handling event ... for ' + attr);
},
'setstart'	: function (ev)
{
console.log ('Starting animation');
XSeen.Tags.animate.destination._xseen.animating.start();
},
'setstop'	: function (ev) 
{
console.log ('Stopping animation');
XSeen.Tags.animate.destination._xseen.animating.stop();
},
'setpause'	: function (ev) 
{
console.log ('Pausing (really stopping) animation');
XSeen.Tags.animate.destination._xseen.animating.stop();
},
'setresetstart'	: function (ev) 	// TODO: Create seperate 'reset' method
{
console.log ('Reset and start animation');
XSeen.Tags.animate.destination._xseen.animatingField = XSeen.Tags.animate.destination._xseen.initialValue;
XSeen.Tags.animate.destination._xseen.animating.start();
},
'Interpolator'	: {
'slerp'	: function (v,k)
{
var m = v.length - 1;
var f = m * k;
var i = Math.floor(f);
if (k < 0) {
return v[0].slerp(v[1], f);
}
if (k > 1) {
return v[m].slerp(v[m-1], m-f);
}
return v[i].slerp (v[i + 1 > m ? m : i + 1], f-i);
},
'color' : function (v,k)
{
var m = v.length - 1;
var f = m * k;
var i = Math.floor(f);
var fn = this.slerpCompute;		// TODO: not sure this is needed
if (k < 0) {
return v[0].lerp(v[1], f);
}
if (k > 1) {
return v[m].lerp(v[m-1], m-f);
}
return v[i].lerp (v[i + 1 > m ? m : i + 1], f - i);
},
},
};
XSeen.Tags.key = {
'init'	: function (e,p) 
{
if (p.nodeName != 'X-ANIMATE') {return; }
var duration = e._xseen.attributes.duration;
if (!p._xseen.keyFraction) {
if (duration <= 0) {return; }
p._xseen.attributes.duration += duration;
} else {
if (duration <= 0 || duration > 1) {return; }
duration *= p._xseen.attributes.duration;
}
XSeen.Tags.animate._easeCheck (e._xseen.attributes.easing, e._xseen.attributes.easingtype, e._xseen.attributes);
var target = XSeen.Tags.animate._getTo (e, p._xseen.attrObject, p._xseen.attributes.attribute);
p._xseen.key.push ({duration:duration, to:target.to, interpolation:target.interpolation, easing:e._xseen.attributes.easing, easingType:e._xseen.attributes.easingtype}) 
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr)
{
console.log ('Handling event ... for ' + attr);
},
};
XSeen.Parser.defineTag ({
'name'	: 'animate',
'init'	: XSeen.Tags.animate.init,
'fin'	: XSeen.Tags.animate.fin,
'event'	: XSeen.Tags.animate.event
})
.defineAttribute ({'name':'attribute', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'to', dataType:'vector', 'defaultValue':[]})
.defineAttribute ({'name':'delay', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'duration', dataType:'float', 'defaultValue':0.0})	// 0.0 ==> key time in seconds
.defineAttribute ({'name':'repeat', dataType:'integer', 'defaultValue':0})
.defineAttribute ({'name':'interpolator', dataType:'string', 'defaultValue':'position', enumeration:['position', 'rotation', 'color'], isCaseInsensitive:true})
.defineAttribute ({'name':'easing', dataType:'string', 'defaultValue':'', enumeration:['', 'in', 'out', 'inout'], isCaseInsensitive:true})
.defineAttribute ({'name':'easingtype', dataType:'string', 'defaultValue':'linear', enumeration:['linear', 'quadratic', 'sinusoidal', 'exponential', 'elastic', 'bounce'], isCaseInsensitive:true})
.defineAttribute ({'name':'yoyo', dataType:'boolean', 'defaultValue':false})
.defineAttribute ({'name':'start', dataType:'boolean', 'defaultValue':true})		// incoming event
.defineAttribute ({'name':'stop', dataType:'boolean', 'defaultValue':true})			// incoming event
.defineAttribute ({'name':'resetstart', dataType:'boolean', 'defaultValue':true})	// incoming event
.defineAttribute ({'name':'pause', dataType:'boolean', 'defaultValue':true})		// incoming event
.addTag();
XSeen.Parser.defineTag ({
'name'	: 'key',
'init'	: XSeen.Tags.key.init,
'fin'	: XSeen.Tags.key.fin,
'event'	: XSeen.Tags.key.event
})
.defineAttribute ({'name':'to', dataType:'vector', 'defaultValue':[]})
.defineAttribute ({'name':'duration', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'easing', dataType:'string', 'defaultValue':'', enumeration:['', 'in', 'out', 'inout'], isCaseInsensitive:true})
.defineAttribute ({'name':'easingtype', dataType:'string', 'defaultValue':'linear', enumeration:['linear', 'quadratic', 'sinusoidal', 'exponential', 'elastic', 'bounce'], isCaseInsensitive:true})
.addTag();
XSeen.Tags.asset = {
'init'	: function (e, p) 
{
},
'fin'	: function (e, p) 
{
},
'event'	: function (ev, attr) {},
};
XSeen.Parser.defineTag ({
'name'	: 'asset',
'init'	: XSeen.Tags.asset.init,
'fin'	: XSeen.Tags.asset.fin,
'event'	: XSeen.Tags.asset.event
})
.addTag();
XSeen.Tags.background = {
'_changeAttribute'	: function (e, attributeName, value) {
console.log ('Changing attribute ' + attributeName + ' of ' + e.localName + '#' + e.id + ' to |' + value + ' (' + e.getAttribute(attributeName) + ')|');
if (value !== null) {
e._xseen.attributes[attributeName] = value;
var type = XSeen.Tags.background._saveAttributes (e);
XSeen.Tags.background._processChange (e);
} else {
XSeen.LogWarn("Re-parse of " + attributeName + " is invalid -- no change")
}
},
'init'	: function (e, p) 
{
function cameraExists () {
const constraints = {video: {facingMode: "environment"}};
function handleError(error) {
console.log ('Device camera not available -- ignoring');
exists = false;
}
var exists = false;
navigator.mediaDevices.enumerateDevices(constraints)
.then(gotDevices).catch(handleError);
function gotDevices(deviceInfos) {
for (var i = 0; i !== deviceInfos.length; ++i) {
var deviceInfo = deviceInfos[i];
console.log('Found a media device matching constraints of type: ' + deviceInfo.kind);
exists = true;
}
}
return true;
}
var t = e._xseen.attributes.radius;
e._xseen.sphereRadius = (t <= 0) ? 500 : t;
e._xseen.sphereDefined = false;
e._xseen.videoState = 'undefined';
var geometry = new THREE.SphereBufferGeometry( e._xseen.sphereRadius, 60, 40 );
geometry.scale(-1, 1, 1);
var material = new THREE.MeshBasicMaterial( {
opacity: 0.0,
transparent: true,
} );
var mesh = new THREE.Mesh( geometry, material );
mesh.name = 'photosphere surface R=' + t;
e._xseen.sphereDefined = true;
e._xseen.sphere = mesh;
mesh = null;
e.parentNode._xseen.children.push(e._xseen.sphere);
if (XSeen.Runtime.mediaAvailable && XSeen.Runtime.isTransparent && cameraExists()) {
var video = document.createElement( 'video' );
video.setAttribute("autoplay", "1"); 
video.height			= XSeen.Runtime.SceneDom.height;
video.width				= XSeen.Runtime.SceneDom.width;
video.style.height		= video.height + 'px';
video.style.width		= video.width + 'px';
video.style.position	= 'absolute';
video.style.top			= '0';
video.style.left		= '0';
video.style.zIndex		= -1;
e._xseen.video			= video;
XSeen.Runtime.RootTag.appendChild (video);
video = null;
e._xseen.videoState		= 'defined';
}
var type = XSeen.Tags.background._saveAttributes (e);
XSeen.Tags.background._processChange (e);
},
'_saveAttributes'	: function (e)
{
var t = e._xseen.attributes.color;
e._xseen.color = new THREE.Color (t.r, t.g, t.b);
e._xseen.imageSource = e._xseen.attributes.src;
e._xseen.srcExtension = e._xseen.attributes.srcextension;
var type = e._xseen.attributes.background;
e._xseen.src = e._xseen.attributes.src;
e._xseen.srcType = XSeen.Tags.background._checkSrc (e._xseen.src);
if (type == 'camera') {
if (e._xseen.videoState == 'undefined') {			// Rollback mechanism
console.log ('Device camera requested, but not available or defined.');
type = 'sky';
} else if (e._xseen.videoState == 'running') {
console.log ('Device camera requested, but it is already running.');
} else if (e._xseen.videoState == 'defined') {
console.log ('Device camera requested, need to engage it.');
} else {
console.log ('Device camera requested, but it is XSeen cannot handled it -- No change to background.');
}
}
e._xseen.backgroundType = type;
return type;
},
'_checkSrc'			: function (url) 
{
return (XSeen.isImage(url)) ? 'image' : 'path';
},
'_processChange'	: function (e)
{
if (e._xseen.videoState == 'running') {
}
if (e._xseen.backgroundType == 'sky') {
e._xseen.sphere.material.transparent = true;
e._xseen.sphere.material.opacity = 0.0;
e._xseen.sceneInfo.SCENE.background = e._xseen.color;
} else if (e._xseen.backgroundType == 'camera') {
e._xseen.sphere.material.transparent = true;
e._xseen.sphere.material.opacity = 0.0;
e._xseen.sceneInfo.SCENE.background = null;
XSeen.Tags.background._setupCamera(e);
} else if (e._xseen.backgroundType == 'fixed') {
e._xseen.sphere.material.transparent = true;
e._xseen.sphere.material.opacity = 0.0;
e._xseen.loadTexture = new THREE.TextureLoader().load (e._xseen.attributes.src);
e._xseen.loadTexture.wrapS = THREE.ClampToEdgeWrapping;
e._xseen.loadTexture.wrapT = THREE.ClampToEdgeWrapping;
e._xseen.sceneInfo.SCENE.background = e._xseen.loadTexture;
} else {
XSeen.Tags.background._loadBackground (e);
}
},
'_setupCamera'		: function (e)
{
const constraints = {video: {facingMode: "environment"}};
if (e._xseen.videoState != 'defined') {
console.log ('Camera/video not correctly configured. Current state: ' + e._xseen.videoState);
return;
}
function handleSuccess(stream) {
e._xseen.video.srcObject = stream;
e._xseen.videoState = 'running';
console.log ('Camera/video engaged and connected to display.');
}
function handleError(error) {
console.log ('Device camera not available -- ignoring');
e._xseen.videoState = 'error';
}
navigator.mediaDevices.getUserMedia(constraints).
then(handleSuccess).catch(handleError);
},
'_loadBackground'	: function (e)
{
if (e._xseen.backgroundType == 'cube' && e._xseen.srcType == 'path') {
var urls=[], files=[];
var files = ['px.', 'nx.', 'py.', 'ny.', 'pz.', 'nz.'];
for (var ii=0;  ii<files.length; ii++) {
urls[ii] = e._xseen.src + files[ii] + e._xseen.srcExtension;
}
console.log ('Loading background image cube');
var dirtyFlag;
XSeen.Loader.TextureCube ('./', urls, '', XSeen.Tags.background.cubeLoadSuccess({'e':e}));
e._xseen.sphere.material.transparent = true;
e._xseen.sphere.material.opacity = 0.0;
} else {		// Sphere-mapped texture. Need to do all of things specified in the above description
if (e._xseen.backgroundType == 'sphere' && e._xseen.srcType == 'image') {
if (!e._xseen.sphereDefined) {
var geometry = new THREE.SphereBufferGeometry( e._xseen.sphereRadius, 60, 40 );
geometry.scale(-1, 1, 1);
var material = new THREE.MeshBasicMaterial( {
map: new THREE.TextureLoader().load(e._xseen.src)
} );
var mesh = new THREE.Mesh( geometry, material );
e._xseen.sphereDefined = true;
e._xseen.sphere = mesh;
mesh = null;
e.parentNode._xseen.children.push(e._xseen.sphere);	// Doesn't work because nothing pushes this up further...
} else {
e._xseen.sphere.material.map = new THREE.TextureLoader().load(e._xseen.src);
e._xseen.sphere.material.transparent = false;
e._xseen.sphere.material.opacity = 1.0;
e._xseen.sphere.material.needsUpdate = true;
console.log (e._xseen.sphere.material);
}
}
}
},
'fin'	: function (e, p) {},
'event'	: function (ev, attr) {},
'tick'	: function (systemTime, deltaTime) {},
'cubeLoadSuccess' : function (userdata)
{
var thisEle = userdata.e;
return function (textureCube)
{
thisEle._xseen.processedUrl = true;
thisEle._xseen.loadTexture = textureCube;
thisEle._xseen.sceneInfo.SCENE.background = textureCube;
console.log ('Successful load of background texture cube.');
}
},
'loadProgress' : function (a)
{
console.log ('Loading background textures...');
},
'loadFailure' : function (a)
{
console.log ('Load failure');
console.log ('Failure to load background textures.');
},
};
XSeen.Parser.defineTag ({
'name'	: 'background',
'init'	: XSeen.Tags.background.init,
'fin'	: XSeen.Tags.background.fin,
'event'	: XSeen.Tags.background.event,
'tick'	: XSeen.Tags.background.tick
})
.defineAttribute ({'name':'color', dataType:'color', 'defaultValue':'black'})
.defineAttribute ({'name':'src', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':500})
.defineAttribute ({'name':'background', dataType:'string', 'defaultValue':'sky', enumeration:['sky', 'cube', 'sphere', 'fixed', 'camera'], isCaseInsensitive:true})
.defineAttribute ({'name':'srcextension', dataType:'string', 'defaultValue':'jpg', enumeration:['jpg', 'jpeg', 'png', 'gif'], isCaseInsensitive:true})
.defineAttribute ({'name':'srcfront', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'srcback', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'srcleft', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'srcright', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'srctop', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'srcbottom', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'backgroundiscube', dataType:'boolean', 'defaultValue':true})
.defineAttribute ({'name':'fixed', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'usecamera', dataType:'boolean', 'defaultValue':'false', 'isAnimatable':false})
.addEvents ({'mutation':[{'attributes':XSeen.Tags.background._changeAttribute}]})
.addTag();
XSeen.Tags.camera = {
'init'	: function (e, p) 
{
e._xseen.properties = {};
e._xseen.domNode = e;	// Back-link to node if needed later on
e._xseen.type = e._xseen.attributes.type;
e._xseen.track = e._xseen.attributes.track;
if (e._xseen.track == 'examine') e._xseen.track = 'trackball';
e._xseen.rendererHasControls = false;		// Only for renderers with built-in controls (e.g., vr)
e._xseen.useDeviceOrientation = false;
e._xseen.isStereographic = false;
e._xseen.priority = e._xseen.attributes.priority;
if (e._xseen.priority < 0) {e._xseen.priority = 1;}
e._xseen.available = e._xseen.attributes.available;
e._xseen.target = null;
if (e._xseen.attributes.target != '') {
var tagElement = document.getElementById (e._xseen.attributes.target);
if (typeof(tagElement) == 'object' && typeof(tagElement._xseen) != 'undefined' && typeof(tagElement._xseen.tagObject) != 'undefined') {
e._xseen.target = tagElement._xseen.tagObject;
}
}
console.log ("Camera type: '"+e._xseen.type+"' with controls " + e._xseen.track);
if (e._xseen.type == 'orthographic') {			// TODO: Orthographic projection
} else if (e._xseen.type == 'perspective') {	// Perspective camera -- default
if (e._xseen.track == 'device') {
if (e._xseen.sceneInfo.hasDeviceOrientation) {
e._xseen.track = (e._xseen.target === null) ? e._xseen.track : 'object'
e._xseen.useDeviceOrientation = true;
} else {
e._xseen.track = 'orbit';
e._xseen.useDeviceOrientation = false;
}
}
} else if (e._xseen.type == 'stereo') {	// Stereo perspective cameras
var track = (e._xseen.target === null) ? e._xseen.track : 'object'
if (e._xseen.track == 'device' && !e._xseen.sceneInfo.hasDeviceOrientation) {track = 'orbit';}
e._xseen.track = track;
e._xseen.isStereographic = true;
e._xseen.rendererHasControls = false;
var button;
button = XSeen.DisplayControl.buttonCreate ('fullscreen', e._xseen.sceneInfo.RootTag, button)
console.log (button);
e._xseen.sceneInfo.RootTag.appendChild(button);
} else if (e._xseen.type == 'vr') {	// Stereo perspective cameras
if (e._xseen.sceneInfo.isVrCapable) {
e._xseen.sceneInfo.Renderer.vr.enabled = true;
e._xseen.sceneInfo.rendererHasControls = true;
document.body.appendChild( WEBVR.createButton( e._xseen.sceneInfo.Renderer ) );
} else if (e._xseen.sceneInfo.hasDeviceOrientation) {
console.log ("VR requested, but no VR device found. Using 'stereo' instead.");
e._xseen.type = 'stereo';
e._xseen.track = 'device';
e._xseen.sceneInfo.Renderer = e._xseen.sceneInfo.RendererStereo;
e._xseen.sceneInfo.rendererHasControls = false;
e._xseen.sceneInfo.isStereographic = true;
} else {													// Flat screen
console.log ("VR requested, but no VR device nor device orientation found. Using 'perspective' instead.");
e._xseen.type = 'perspective';
e._xseen.track = 'orbit';
}
}
if (!e._xseen.rendererHasControls) {
if (e._xseen.sceneInfo.useDeviceOrientation) {
if (e._xseen.track == 'object') {	// tracking scene object
e._xseen.sceneInfo.CameraControl = new THREE.DeviceOrientationControls(e._xseen.target, true);
} else {							// tracking environment
e._xseen.sceneInfo.CameraControl = new THREE.DeviceOrientationControls(e._xseen.sceneInfo.Camera);
}
} else {								// No device orientation control. Use something else
if (e._xseen.track == 'orbit') {
e._xseen.sceneInfo.CameraControl = new THREE.OrbitControls( e._xseen.sceneInfo.Camera, e._xseen.sceneInfo.RendererStandard.domElement );
} else if (e._xseen.track == 'trackball') {
} else if (e._xseen.track == 'none') {
console.log (e.id + ' has NO tracking');
e._xseen.rendererHasControls = false;
} else {
console.log ('Something else');
}
}
}
e._xseen.sceneInfo.ViewManager.add (e);
},
'fin'	: function (e, p) 
{
e.setActive = function () {
XSeen.CameraManager.setActive(this);
}
},
'event'	: function (ev, attr)
{
},
'tick'	: function (systemTime, deltaTime)
{
},
};
XSeen.Parser.defineTag ({
'name'	: 'camera',
'init'	: XSeen.Tags.camera.init,
'fin'	: XSeen.Tags.camera.fin,
'event'	: XSeen.Tags.camera.event,
'tick'	: XSeen.Tags.camera.tick
})
.addSceneSpace()
.defineAttribute ({'name':'type', dataType:'string', 'defaultValue':'perspective', enumeration:['perspective','stereo','orthographic','vr'], isCaseInsensitive:true})
.defineAttribute ({'name':'track', dataType:'string', 'defaultValue':'none', enumeration:['none', 'orbit', 'fly', 'examine', 'trackball', 'device'], isCaseInsensitive:true})
.defineAttribute ({'name':'priority', dataType:'integer', 'defaultValue':1})
.defineAttribute ({'name':'available', dataType:'boolean', 'defaultValue':true})
.defineAttribute ({'name':'target', dataType:'string', 'defaultValue':''})
.addTag();
XSeen.Tags.fog = {
'init'	: function (e, p) 
{
console.log ('Creating FOG with color ' + XSeen.Parser.Types.colorRgbInt(e._xseen.attributes.color));
console.log (e._xseen.attributes.color);
var fog = new THREE.Fog (
XSeen.Parser.Types.colorRgbInt(e._xseen.attributes.color),
e._xseen.attributes.near,
e._xseen.attributes.far);
e._xseen.tagObject = fog;
e._xseen.sceneInfo.SCENE.fog = fog;
},
'fin'	: function (e, p) {},
'event'	: function (ev, attr)
{
},
'tick'	: function (systemTime, deltaTime)
{
},
};
XSeen.Parser.defineTag ({
'name'	: 'fog',
'init'	: XSeen.Tags.fog.init,
'fin'	: XSeen.Tags.fog.fin,
'event'	: XSeen.Tags.fog.event,
'tick'	: XSeen.Tags.fog.tick
})
.addSceneSpace()
.defineAttribute ({'name':'color', dataType:'color', 'defaultValue':'white'})
.defineAttribute ({'name':'near', dataType:'float', 'defaultValue':'1'})
.defineAttribute ({'name':'far', dataType:'float', 'defaultValue':'1'})
.addTag();
XSeen.Tags.group = {
'init'	: function (e, p) 
{
var group = new THREE.Group();
var rotation = {'x':0, 'y':0, 'z':0, 'w':0};
group.name = 'Transform children [' + e.id + ']';
group.position.x	= e._xseen.attributes.position.x;
group.position.y	= e._xseen.attributes.position.y;
group.position.z	= e._xseen.attributes.position.z;
group.scale.x		= e._xseen.attributes.scale.x;
group.scale.y		= e._xseen.attributes.scale.y;
group.scale.z		= e._xseen.attributes.scale.z;
group.setRotationFromQuaternion (e._xseen.attributes.rotation);
var bx, by, bz, q, tx, ty, tz;
q = group.quaternion;
bx = new THREE.Vector3 (1, 0, 0);
by = new THREE.Vector3 (0, 1, 0);
bz = new THREE.Vector3 (0, 0, 1);
bx = bx.applyQuaternion (q);
by = by.applyQuaternion (q);
bz = bz.applyQuaternion (q);
e._xseen.properties = e._xseen.properties || [];
e._xseen.properties['rotatex'] = Math.atan2 (bx.z, bx.y);
e._xseen.properties['rotatey'] = Math.atan2 (by.z, by.x);
e._xseen.properties['rotatez'] = Math.atan2 (bz.y, bz.x);
e._xseen.animate['rotation'] = group.quaternion;
e._xseen.animate['rotatex'] = 'rotateX';
e._xseen.animate['rotatey'] = 'rotateY';
e._xseen.animate['rotatez'] = 'rotateZ';
e._xseen.animate['position']	= group.position;
e._xseen.animate['scale']		= group.scale;
e._xseen.animate['rotate-x']	= XSeen.Tags.Solids._animateRotation (group, 'rotateX');
e._xseen.animate['rotate-y']	= XSeen.Tags.Solids._animateRotation (group, 'rotateY');
e._xseen.animate['rotate-z']	= XSeen.Tags.Solids._animateRotation (group, 'rotateZ');
e._xseen.loadGroup = group;
e._xseen.tagObject = e._xseen.loadGroup;
e._xseen.update = XSeen.Tags.group.animateObject;
},
'fin'	: function (e, p) 
{
e._xseen.children.forEach (function (child, ndx, wholeThing)
{
e._xseen.loadGroup.add(child);
});
p._xseen.children.push(e._xseen.loadGroup);
},
'event'	: function (ev, attr) {},
'tick'	: function (systemTime, deltaTime) {},
'setactive'	: function (ev) {},
'animateObject'	: function (x, property, value) 
{
x.loadGroup[property](value);
console.log (value);
},
};
XSeen.Parser.defineTag ({
'name'	: 'group',
'init'	: XSeen.Tags.group.init,
'fin'	: XSeen.Tags.group.fin,
'event'	: XSeen.Tags.group.event,
'tick'	: XSeen.Tags.group.tick
})
.addSceneSpace()
.addTag();
XSeen.Tags.label = {
'selectedLabel'	: {},
'init'	: function (e, p) 
{
var type = e._xseen.attributes.type;
if (!(type == 'fixed' || type == 'tracking' || type == 'draggable')) {type = 'fixed';}
e._xseen.labelType = type;
e._xseen.targets = [];
e._xseen.tagObject = [];
},
'fin'	: function (e, p)
{
var labelElement, targetElement, targetPosition, labelPosition, positionedInSpace;
var material;
labelElement = e.getElementsByTagName('div')[0];
labelPosition = new THREE.Vector3(0, 0, -1);	// center of near-clipping plane
positionedInSpace = false;
if (e._xseen.attributes.position.x != 0 || e._xseen.attributes.position.y != 0) {
e._xseen.attributes.position.z = -1;
positionedInSpace = true;
}
material = new THREE.LineBasicMaterial( {color: XSeen.Parser.Types.colorRgbInt(e._xseen.attributes['leadercolor']), } );
e._xseen.labelObj = [];
for (var ii=0; ii<e._xseen.targets.length; ii++) {
targetElement = e._xseen.targets[ii];
targetPosition = new THREE.Vector3();
targetElement._xseen.tagObject.getWorldPosition(targetPosition);
var geometry = new THREE.Geometry();
var line = new THREE.Line( geometry, material );
var labelObj = {
'method'		: XSeen.Tags.label.tick,
'position'		: XSeen.Tags.label['position_'+e._xseen.labelType],
'node'			: e,
'_xseen'		: e._xseen,
'RunTime'		: e._xseen.sceneInfo,
'target'		: targetElement,
'targetWorld'	: new THREE.Vector3(),
'label'			: labelElement,
'labelWorld'	: new THREE.Vector3(0, 0, -1),
'labelDelta'	: {x: 0, y: 0},
'line'			: line,
'initialized'	: false,
'spacePosition'	: positionedInSpace,
};
targetElement._xseen.tagObject.getWorldPosition(labelObj.targetWorld);
geometry.vertices.push(
labelObj.targetWorld,
labelObj.labelWorld);
labelObj.line.geometry.verticesNeedUpdate = true;
e._xseen.sceneInfo.perFrame.push ({'method':XSeen.Tags.label.tick, 'userdata':labelObj});
e._xseen.tagObject.push (line);
p._xseen.children.push (line);
}
e.addEventListener ('xseen', XSeen.Tags.label.tick, true);						// Render frame
if (e._xseen.labelType == 'draggable') {
labelElement.addEventListener ('mousedown', XSeen.Tags.label.MouseDown);	// label movement if type='draggable'
}
},
'event'	: function (ev, attr) {},
'tick'	: function (rt, label)
{
label.position (rt, label);
label.target._xseen.tagObject.getWorldPosition(label.targetWorld);
label.line.geometry.verticesNeedUpdate = true;
},
'MouseDown' : function (ev)
{
XSeen.Tags.label.selectedLabel.state = 'down';
XSeen.Tags.label.selectedLabel.element = ev.target;
XSeen.Tags.label.selectedLabel.pointerOffset = [ev.x-this.offsetLeft, ev.y-this.offsetTop];
this.addEventListener ('mousemove', XSeen.Tags.label.MouseMove);
this.addEventListener ('mouseup', XSeen.Tags.label.MouseUp);
},
'MouseUp'	: function (ev)
{
XSeen.Tags.label.selectedLabel.element.removeEventListener ('mousemove', XSeen.Tags.label.MouseMove);
XSeen.Tags.label.selectedLabel.element.removeEventListener ('mouseup', XSeen.Tags.label.MouseUp);
XSeen.Tags.label.selectedLabel.state = '';
XSeen.Tags.label.selectedLabel.element = {};
},
'MouseMove'	: function (ev)
{
XSeen.Tags.label.selectedLabel.state = 'move';
this.style.left = ev.x - XSeen.Tags.label.selectedLabel.pointerOffset[0] + 'px';
this.style.top  = ev.y - XSeen.Tags.label.selectedLabel.pointerOffset[1] + 'px';
ev.cancelBubble = true;
},
'position_draggable'	: function (rt, label)
{
label.position = XSeen.Tags.label.position_fixed;
label.position (rt, label);
},
'position_fixed'	: function (rt, label)
{
label.labelWorld.x = 0 -1 + 2 * (label.label.offsetLeft + label.label.offsetWidth/2)   * rt.Size.iwidth;
label.labelWorld.y = 0 +1 - 2 * (label.label.offsetTop  + label.label.offsetHeight/2) * rt.Size.iheight;
label.labelWorld.z = -1;
label.labelWorld = label.labelWorld.unproject (rt.Camera);
label.labelWorld.initialized = true;
},
'position_tracking'	: function (rt, label)
{
var projected = label.targetWorld.clone();
projected.project(rt.Camera);
var w2, h2, labelx, labely;
w2 = rt.Size.width / 2;
h2 = rt.Size.height / 2;
projected.x = w2 + (projected.x * w2);
projected.y = h2 - (projected.y * h2);
if (!label.initialized) {
label.labelDelta.x = projected.x - label.label.offsetLeft;
label.labelDelta.y = projected.y - label.label.offsetTop;
label.initialized = true;
}
labelx = projected.x - label.labelDelta.x;
labely = projected.y - label.labelDelta.y;
label.label.style.left = labelx + 'px';
label.label.style.top  = labely + 'px';
XSeen.Tags.label.position_fixed (rt, label);
},
};
XSeen.Tags.leader = {
'init'	: function (e, p) 
{
var targetElement = document.getElementById (e._xseen.attributes.target);
if (typeof(targetElement) === 'undefined' || targetElement === null) {return;}
p._xseen.targets.push (targetElement);
},
'fin'	: function (e, p) {},
'event'	: function (ev, attr) {},
};
XSeen.Parser.defineTag ({
'name'	: 'label',
'init'	: XSeen.Tags.label.init,
'fin'	: XSeen.Tags.label.fin,
'event'	: XSeen.Tags.label.event
})
.defineAttribute ({'name':'type', dataType:'string', 'defaultValue':'fixed', enumeration:['fixed', 'draggable', 'tracking'], isCaseInsensitive:true, 'isAnimatable':false})
.defineAttribute ({'name':'position', dataType:'xyz', 'defaultValue':{x:0, y:0, z:0}})
.defineAttribute ({'name':'leadercolor', dataType:'color', 'defaultValue':{'r':1,'g':1,'b':0}})
.addTag();
XSeen.Parser.defineTag ({
'name'	: 'leader',
'init'	: XSeen.Tags.leader.init,
'fin'	: XSeen.Tags.leader.fin,
'event'	: XSeen.Tags.leader.event
})
.defineAttribute ({'name':'target', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.addTag();
XSeen.Tags.light = {
'_changeAttribute'	: function (e, attributeName, value) {
console.log ('Changing attribute ' + attributeName + ' of ' + e.localName + '#' + e.id + ' to |' + value + ' (' + e.getAttribute(attributeName) + ')|');
if (value !== null) {
e._xseen.attributes[attributeName] = value;
XSeen.Tags.light._processChange (e);
} else {
XSeen.LogWarn("Re-parse of " + attributeName + " is invalid -- no change")
}
},
'_processChange'	: function (e, attributeName, value) {
var lamp, color, intensity;
color = e._xseen.attributes.color;
intensity = e._xseen.attributes.intensity - 0;
lamp = e._xseen.tagObject;
if (!e._xseen.attributes.on) {intensity = 0;}
lamp.intensity = intensity;
lamp.color = color;
},
'init'	: function (e,p) 
{
var color = e._xseen.attributes.color;
var intensity = e._xseen.attributes.intensity - 0;
var lamp, type=e._xseen.attributes.type;
if (!e._xseen.attributes.on) {intensity = 0;}
if (type == 'point') {
lamp = new THREE.PointLight (color, intensity);
lamp.distance = Math.max(0.0, e._xseen.attributes.radius - 0);
lamp.decay = Math.max (.1, e._xseen.attributes.attenuation[1]/2 + e._xseen.attributes.attenuation[2]);
} else if (type == 'spot') {
lamp = new THREE.SpotLight (color, intensity);
lamp.position.set(0-e._xseen.attributes.direction[0], 0-e._xseen.attributes.direction[1], 0-e._xseen.attributes.direction[2]);
lamp.distance = Math.max(0.0, e._xseen.attributes.radius - 0);
lamp.decay = Math.max (.1, e._xseen.attributes.attenuation[1]/2 + e._xseen.attributes.attenuation[2]);
lamp.angle = Math.max(0.0, Math.min(1.5707963267948966192313216916398, e._xseen.attributes.cutoffangle));
lamp.penumbra = 1 - Math.max(0.0, Math.min(lamp.angle, e._xseen.attributes.beamwidth)) / lamp.angle;
} else {											// DirectionalLight (by default)
lamp = new THREE.DirectionalLight (color, intensity);
lamp.position.x = 0-e._xseen.attributes.direction[0];
lamp.position.y = 0-e._xseen.attributes.direction[1];
lamp.position.z = 0-e._xseen.attributes.direction[2];
}
lamp.name = 'Light: ' + e.id;
e._xseen.tagObject = lamp;
p._xseen.children.push(lamp);
lamp = null;
},
'fin'	: function (e,p)
{
},
'event'	: function (ev, attr)
{
},
'tick'	: function (systemTime, deltaTime)
{
},
};
XSeen.Parser.defineTag ({
'name'	: 'light',
'init'	: XSeen.Tags.light.init,
'fin'	: XSeen.Tags.light.fin,
'event'	: XSeen.Tags.light.event,
'tick'	: XSeen.Tags.light.tick
})
.defineAttribute ({'name':'on', dataType:'boolean', 'defaultValue':true})
.defineAttribute ({'name':'color', dataType:'color', 'defaultValue':0xFFFFFF, 'isAnimatable':true})
.defineAttribute ({'name':'intensity', dataType:'float', 'defaultValue':1.0, 'isAnimatable':true})
.defineAttribute ({'name':'type', dataType:'string', 'defaultValue':'directional', enumeration:['directional','spot','point'], isCaseInsensitive:true, 'isAnimatable':false})
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':100, 'isAnimatable':true})
.defineAttribute ({'name':'attenuation', dataType:'vec3', 'defaultValue':[1,0,0], 'isAnimatable':false})
.defineAttribute ({'name':'direction', dataType:'vec3', 'defaultValue':[0,0,-1], 'isAnimatable':true})
.defineAttribute ({'name':'cutoffangle', dataType:'float', 'defaultValue':3.14, 'isAnimatable':true})
.defineAttribute ({'name':'beamwidth', dataType:'float', 'defaultValue':1.57, 'isAnimatable':true})
.addEvents ({'mutation':[{'attributes':XSeen.Tags.light._changeAttribute}]})
.addTag();
XSeen.Tags.metadata = {
'init'	: function (e, p) 
{
e._xseen.tmp.meta = [];
e._xseen.tmp.meta.push (e._xseen.attributes.value);
if (typeof(p._xseen.tmp.meta) == 'undefined') {p._xseen.tmp.meta = [];}
},
'fin'	: function (e, p) 
{
if (e._xseen.tmp.meta.length == 1) {		// this is a leaf tag
p._xseen.tmp.meta.push (e._xseen.tmp.meta[0]);
e._xseen.Metadata.push (e._xseen.tmp.meta[0]);
} else {
p._xseen.tmp.meta.push (e._xseen.tmp.meta);
e._xseen.Metadata.push (e._xseen.tmp.meta);
}
if (e._xseen.attributes.name != '') {p._xseen.tmp.meta[e._xseen.attributes.name] = p._xseen.tmp.meta[p._xseen.tmp.meta.length-1];}
e._xseen.tmp.meta = [];
},
'event'	: function (ev, attr) {},
'changeValue'	: function (ev, attr) 
{
},
};
XSeen.Parser.defineTag ({
'name'	: 'metadata',
'init'	: XSeen.Tags.metadata.init,
'fin'	: XSeen.Tags.metadata.fin,
'event'	: XSeen.Tags.metadata.event
})
.defineAttribute ({'name':'name', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'value', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'type', dataType:'string', 'defaultValue':'string', enumeration:['string','integer', 'float', 'vector', 'object'], isCaseInsensitive:true, 'isAnimatable':false})
.addEvents ({'mutation':[{'attributes':XSeen.Tags.metadata.changeValue}]})
.addTag();
XSeen.Tags.model = {
'init'	: function (e, p) 
{
e._xseen.processedUrl = false;
e._xseen.tmpGroup = new THREE.Group();
e._xseen.tmpGroup.name = 'External Model [' + e.id + ']';
e._xseen.loadGroup = new THREE.Group();
e._xseen.loadGroup.name = 'External Model [' + e.id + ']';
e._xseen.loadGroup.name = 'Parent of |' + e._xseen.tmpGroup.name  + '|';
e._xseen.loadGroup.add (e._xseen.tmpGroup);
XSeen.Tags._setSpace (e._xseen.tmpGroup, e._xseen.attributes);
XSeen.Loader.load (e._xseen.attributes.src, e._xseen.attributes.hint, XSeen.Tags.model.loadSuccess({'e':e, 'p':p}), XSeen.Tags.model.loadFailure, XSeen.Tags.model.loadProgress);
e._xseen.requestedUrl = true;
e._xseen.tagObject = e._xseen.loadGroup;
p._xseen.children.push(e._xseen.loadGroup);
},
'fin'	: function (e, p) {},
'event'	: function (ev, attr) {},
'tick'	: function (systemTime, deltaTime) {},
'loadProgress' : function (a1) {
if (a1.total == 0) {
console.log ('Progress loading '+a1.type);
} else {
console.log ('Progress ('+a1.type+'): ' + a1.loaded/a1.total * 100 + '%');
}
},
'loadFailure' : function (a1) {
console.log ('Failure ('+a1.type+'): ' + a1.timeStamp);
},
'loadSuccess' : function (userdata) {
var e = userdata.e;
var p  = userdata.p;
return function (response) {
e._xseen.processedUrl = true;
e._xseen.requestedUrl = false;
e._xseen.loadText = response;
e._xseen.currentUrl = e._xseen.attributes.src;
console.log("Successful download for |"+e.id+'|');
e._xseen.tmpGroup.add(response.scene);		// This works for glTF
console.log ('glTF loading complete and inserted into parent');
XSeen.Tags.model.addReferenceToRoot (response.scene, e);
p._xseen.sceneInfo.selectable.push(response.scene)
p._xseen.sceneInfo.SCENE.updateMatrixWorld();
if (response.animations !== null) {				// This is probably glTF specific
e._xseen.mixer = new THREE.AnimationMixer (response.scene);
e._xseen.sceneInfo.Mixers.push (e._xseen.mixer);
} else {
e._xseen.mixer = null;
}
if (e._xseen.attributes.playonload != '' && e._xseen.mixer !== null) {			// separate method?
if (e._xseen.attributes.playonload == '*') {			// Play all animations
response.animations.forEach( function ( clip ) {
console.log('  starting animation for '+clip.name);
if (e._xseen.attributes.duration > 0) {clip.duration = e._xseen.attributes.duration;}
e._xseen.mixer.clipAction( clip ).play();
} );
} else {											// Play a specific animation
var clip = THREE.AnimationClip.findByName(response.animations, e._xseen.attributes.playonload);
var action = e._xseen.mixer.clipAction (clip);
action.play();
}
}
}
},
'addReferenceToRoot' : function (ele, root)
{
ele.userData.root = root;
ele.children.forEach (function(elm) {
XSeen.Tags.model.addReferenceToRoot (elm, root);
});
},
};
XSeen.Parser.defineTag ({
'name'	: 'model',
'init'	: XSeen.Tags.model.init,
'fin'	: XSeen.Tags.model.fin,
'event'	: XSeen.Tags.model.event,
'tick'	: XSeen.Tags.model.tick
})
.addSceneSpace()
.defineAttribute ({'name':'src', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'hint', dataType:'string', 'defaultValue':''})	// loader hint - typically version #
.defineAttribute ({'name':'playonload', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'duration', dataType:'float', 'defaultValue':-1, 'isAnimatable':false})
.addTag();
XSeen.Tags.scene = {
'DEFAULT'	: {
'Viewpoint'	: {
'Position'		: [0, 0, 10],
'Orientation'	: [0, 1, 0, 0],		// TODO: fix (and below) when handling orientation
'Type'			: 'perpsective',
'Motion'		: 'none',
'MotionSpeed'	: 1.0,
},
'Navigation' : {
'Speed'		: 1.0,		// 16 spr (1 revolution per 16 seconds), in mseconds.
'Type'		: 'none',
'Setup'		: 'none',
}
},
'init'	: function (e, p) 
{
e._xseen.sceneInfo.SCENE = new THREE.Scene();
var x_effect = new THREE.StereoEffect(e._xseen.sceneInfo.Renderer);
},
'fin'	: function (e, p) 
{
window.addEventListener ('resize', XSeen.Runtime.Resize, false);
e._xseen.sceneInfo.ViewManager.setNext();
if (e._xseen.attributes.cubetest) {
XSeen.LogInfo("Kicking off THREE testing code and rendering");
DoRestOfCubes (e._xseen.sceneInfo);
} else {
XSeen.Runtime.Animate();
}
},
'resize': function () {
var thisTag = XSeen.Runtime.RootTag;
XSeen.Runtime.Camera.aspect = thisTag.offsetWidth / thisTag.offsetHeight;
XSeen.Runtime.Camera.updateProjectionMatrix();
XSeen.Runtime.Renderer.setSize (thisTag.offsetWidth, thisTag.offsetHeight)
},
'addScene': function () {
var e = XSeen.Runtime.RootTag;
console.log ('Adding children to SCENE');
e._xseen.idReference = e._xseen.idReference || Array();
e._xseen.children.forEach (function (child, ndx, wholeThing)
{
if (e._xseen.idReference[child.id] === undefined) {
console.log('Adding child of type ' + child.type + ' (' + child.name + '/' + child.id + ') with ' + child.children.length + ' children to THREE scene');
e._xseen.sceneInfo.SCENE.add(child);
e._xseen.idReference[child.id] = child;
}
});
},
'event'	: function (ev, attr)
{
},
'tick'	: function (systemTime, deltaTime)
{
},
};
XSeen.Parser.defineTag ({
'name'	: 'scene',
'init'	: XSeen.Tags.scene.init,
'fin'	: XSeen.Tags.scene.fin,
'event'	: XSeen.Tags.scene.event,
'tick'	: XSeen.Tags.scene.tick
})
.defineAttribute ({'name':'cubetest', dataType:'boolean', 'defaultValue':false})
.addTag();
XSeen.Tags.Solids = {};
XSeen.Tags._appearance = function (e) {
e._xseen.texture = null;
if (e._xseen.attributes['map'] !== '') {
console.log ('Loading texture: |'+e._xseen.attributes['map']+'|');
e._xseen.texture = new THREE.TextureLoader().load (e._xseen.attributes['map']);
e._xseen.texture.wrapS = THREE.ClampToEdgeWrapping;
e._xseen.texture.wrapT = THREE.ClampToEdgeWrapping;
}
e._xseen.properties['side'] = THREE.FrontSide;
if (e._xseen.attributes['side'] == 'back') e._xseen.properties['side'] = THREE.BackSide;
if (e._xseen.attributes['side'] == 'both') e._xseen.properties['side'] = THREE.DoubleSide;
var parameters, appearance;
if (e._xseen.attributes.material != '') {
var ele = document.getElementById (e._xseen.attributes.material);
if (typeof(ele) != 'undefined') {
console.log ('Using asset material: ' + e._xseen.attributes.material);
appearance = ele._xseen.tagObject;
} else {
console.log ('Reference to undeclared material: ' + e._xseen.attributes.material);
appearance = {};
}
} else if (e._xseen.attributes.type == 'phong') {
parameters = {
'aoMap'					: e._xseen.attributes['ambient-occlusion-map'],
'aoMapIntensity'		: e._xseen.attributes['ambient-occlusion-map-intensity'],
'color'					: XSeen.Parser.Types.colorRgbInt (e._xseen.attributes['color']),
'displacementMap'		: e._xseen.attributes['displacement-map'],
'displacementScale'		: e._xseen.attributes['displacement-scale'],
'displacementBias'		: e._xseen.attributes['displacement-bias'],
'emissive'				: e._xseen.attributes['emissive'],
'map'					: e._xseen.texture,
'normalMap'				: e._xseen.attributes['normal-map'],
'normalScale'			: e._xseen.attributes['normal-scale'],
'side'					: e._xseen.properties['side'],
'wireframe'				: e._xseen.attributes['wireframe'],
'wireframeLinewidth'	: e._xseen.attributes['wireframe-linewidth'],
'emissiveIntensity'		: e._xseen.attributes['emissive-intensity'],
'opacity'				: e._xseen.attributes['opacity'],
'transparent'			: e._xseen.attributes['transparent'],
'reflectivity'			: e._xseen.attributes['reflectivity'],
'refractionRatio'		: e._xseen.attributes['refraction-ratio'],
'shininess'				: e._xseen.attributes['shininess'],
'specular'				: e._xseen.attributes['specular'],
};
appearance = new THREE.MeshPhongMaterial(parameters);
} else if (e._xseen.attributes.type == 'pbr') {
parameters = {
'aoMap'					: e._xseen.attributes['ambient-occlusion-map'],
'aoMapIntensity'		: e._xseen.attributes['ambient-occlusion-map-intensity'],
'color'					: XSeen.Parser.Types.colorRgbInt (e._xseen.attributes['color']),
'displacementMap'		: e._xseen.attributes['displacement-map'],
'displacementScale'		: e._xseen.attributes['displacement-scale'],
'displacementBias'		: e._xseen.attributes['displacement-bias'],
'emissive'				: e._xseen.attributes['emissive'],
'map'					: e._xseen.texture,
'normalMap'				: e._xseen.attributes['normal-map'],
'normalScale'			: e._xseen.attributes['normal-scale'],
'side'					: e._xseen.properties['side'],
'wireframe'				: e._xseen.attributes['wireframe'],
'wireframeLinewidth'	: e._xseen.attributes['wireframe-linewidth'],
'emissiveIntensity'		: e._xseen.attributes['emissive-intensity'],
'opacity'				: e._xseen.attributes['opacity'],
'transparent'			: e._xseen.attributes['transparent'],
'reflectivity'			: e._xseen.attributes['reflectivity'],
'refractionRatio'		: e._xseen.attributes['refraction-ratio'],
'metalness'				: e._xseen.attributes['metalness'],
'roughness'				: e._xseen.attributes['roughness'],
};
appearance = new THREE.MeshPhysicalMaterial(parameters);
} else {
parameters = {
'aoMap'					: e._xseen.attributes['ambient-occlusion-map'],
'aoMapIntensity'		: e._xseen.attributes['ambient-occlusion-map-intensity'],
'color'					: XSeen.Parser.Types.colorRgbInt (e._xseen.attributes['color']),
'displacementMap'		: e._xseen.attributes['displacement-map'],
'displacementScale'		: e._xseen.attributes['displacement-scale'],
'displacementBias'		: e._xseen.attributes['displacement-bias'],
'emissive'				: e._xseen.attributes['emissive'],
'map'					: e._xseen.texture,
'normalMap'				: e._xseen.attributes['normal-map'],
'normalScale'			: e._xseen.attributes['normal-scale'],
'side'					: e._xseen.properties['side'],
'wireframe'				: e._xseen.attributes['wireframe'],
'wireframeLinewidth'	: e._xseen.attributes['wireframe-linewidth'],
'emissiveIntensity'		: e._xseen.attributes['emissive-intensity'],
'opacity'				: e._xseen.attributes['opacity'],
'transparent'			: e._xseen.attributes['transparent'],
};
appearance = new THREE.MeshBasicMaterial(parameters);
}
return appearance;
}
XSeen.Tags._solid = function (e, p, geometry) {
var appearance = XSeen.Tags._appearance (e);
var mesh = new THREE.Mesh (geometry, appearance);
mesh.userData = e;
XSeen.Tags._setSpace(mesh, e._xseen.attributes);
e._xseen.animate['position']			= mesh.position;
e._xseen.animate['scale']				= mesh.scale;
e._xseen.animate['rotate-x']			= XSeen.Tags.Solids._animateRotation (mesh, 'rotateX');
e._xseen.animate['rotate-y']			= XSeen.Tags.Solids._animateRotation (mesh, 'rotateY');
e._xseen.animate['rotate-z']			= XSeen.Tags.Solids._animateRotation (mesh, 'rotateZ');
e._xseen.animate['color']				= mesh.material.color;
e._xseen.animate['emissive']			= mesh.material.emissive;
e._xseen.animate['normalScale']			= mesh.material.normalScale;
e._xseen.animate['wireframeLinewidth']	= mesh.material.wireframeLinewidth;
e._xseen.animate['emissiveIntensity']	= mesh.material.emissiveIntensity;
e._xseen.animate['opacity']				= XSeen.Tags.Solids._animateScalar (mesh.material, 'opacity');
e._xseen.animate['reflectivity']		= mesh.material.reflectivity;
e._xseen.animate['refractionRatio']		= mesh.material.refractionRatio;
e._xseen.animate['shininess']			= mesh.material.shininess;
e._xseen.animate['specular']			= mesh.material.specular;
e._xseen.animate['displacementScale']	= mesh.material.displacementScale;
e._xseen.animate['displacementBias']	= mesh.material.displacementBias;
e._xseen.animate['emissive']			= mesh.material.emissive;
e._xseen.animate['normalScale']			= mesh.material.normalScale;
e._xseen.animate['metalness']			= mesh.material.metalness;
e._xseen.animate['roughness']			= mesh.material.roughness;
if (e._xseen.attributes.selectable) p._xseen.sceneInfo.selectable.push(mesh);
mesh.name = 'Solid: ' + e.id;
e._xseen.tagObject = mesh;
p._xseen.children.push(mesh);
e._xseen.properties.envMap = XSeen.Tags.Solids._envMap(e, e._xseen.attributes['env-map']);
};
XSeen.Tags.Solids._animateScalar = function (obj, field) {
var target = {'obj':obj, 'field':field};
return function (td) {
target.obj[target.field] = td.current;
};
}
XSeen.Tags.Solids._animateRotation = function (obj, field) {
if (typeof(obj.userData.previousRotation) == 'undefined') {obj.userData.previousRotation = {'x':0, 'y':0, 'z':0};}
var target = {'obj':obj, 'field':field};
if (field == 'rotateX') {
return function (td) {
var rotation = td.current - target.obj.userData.previousRotation.x;
target.obj.rotateX(rotation);
target.obj.userData.previousRotation.x = td.current;
};
}
if (field == 'rotateY') {
return function (td) {
var rotation = td.current - target.obj.userData.previousRotation.y;
target.obj.rotateY(rotation);
target.obj.userData.previousRotation.y = td.current;
};
}
if (field == 'rotateZ') {
return function (td) {
var rotation = td.current - target.obj.userData.previousRotation.z;
target.obj.rotateZ(rotation);
target.obj.userData.previousRotation.z = td.current;
};
}
}
XSeen.Tags.Solids._changeAttribute = function (e, attributeName, value) {
if (value !== null) {
e._xseen.attributes[attributeName] = value;
var baseMaterial, baseGeometry, baseMesh, baseType='';
if (e._xseen.tagObject.isMesh) {
baseMaterial	= e._xseen.tagObject.material;
baseGeometry	= e._xseen.tagObject.geometry;
baseMesh		= e._xseen.tagObject;
baseType		= 'mesh';
} else if (e._xseen.tagObject.isMaterial) {
baseMaterial	= e._xseen.tagObject;
baseType		= 'material';
} else if (e._xseen.tagObject.isGeometry) {
baseGeometry	= e._xseen.tagObject;
baseType		= 'geometry';
}
if (attributeName == 'color') {				// Different operation for each attribute
baseMaterial.color.setHex(value);	// Solids are stored in a 'group' of the tagObject
baseMaterial.needsUpdate = true;
} else if (attributeName == 'env-map') {				// Different operation for each attribute
e._xseen.properties.envMap = XSeen.Tags.Solids._envMap(e, value);
} else if (attributeName == 'metalness') {
baseMaterial.metalness = value;
} else if (attributeName == 'roughness') {
baseMaterial.roughness = value;
} else if (attributeName == 'position') {
console.log ('Setting position to ' + value);
baseMesh.position.x = value.x;
baseMesh.position.y = value.y;
baseMesh.position.z = value.z;
} else if (attributeName == 'material') {
var ele = document.getElementById (value);
if (typeof(ele) != 'undefined') {
console.log ('Changing to asset material: ' + value);
e._xseen.tagObject.material = ele._xseen.tagObject;
} else {
console.log ('No material asset: |'+value+'|');
}
} else {
XSeen.LogWarn('No support for updating ' + attributeName);
}
} else {
XSeen.LogWarn("Reparse of " + attributeName + " is invalid -- no change")
}
};
XSeen.Tags.Solids._envMap = function (e, envMapUrl) {
var envMap, basePath = 'Resources/textures/';
envMap = null;
XSeen.Loader.TextureCube (envMapUrl, [], '.jpg', XSeen.Tags.Solids.loadSuccess({'e':e}));
return envMap;
};
XSeen.Tags.Solids.loadSuccess = function (userdata) {
var thisEle = userdata.e;
return function (textureCube)
{
if (thisEle._xseen.tagObject.type == 'Material') {
thisEle._xseen.tagObject.envMap = textureCube;
thisEle._xseen.tagObject.needsUpdate = true;
} else {
thisEle._xseen.tagObject.material.envMap = textureCube;
thisEle._xseen.tagObject.material.needsUpdate = true;
}
console.log ('Successful load of environment textures.');
}
};
XSeen.Tags._geometry = function (e, shape) {
if (typeof(e._xseen.attributes.geometry) != 'undefined' && e._xseen.attributes.geometry != '') {
var ele = document.getElementById (e._xseen.attributes.geometry);
if (typeof(ele) != 'undefined') {
console.log ('Using asset geometry: ' + e._xseen.attributes.geometry + '(' + ele._xseen.tagObject.type + ')');
if (ele._xseen.tagObject.type.toLowerCase() == shape+'geometry') {
return ele._xseen.tagObject;
} else {
console.log ('-- mismatch between requested shape and asset geometry');
}
} else {
console.log ('Reference to undeclared material: ' + e._xseen.attributes.material);
}
return new THREE.Geometry();
}
var geometry;
if (shape == 'box') {
geometry = new THREE.BoxGeometry(
e._xseen.attributes.width, 
e._xseen.attributes.height, 
e._xseen.attributes.depth,
e._xseen.attributes['segments-width'], 
e._xseen.attributes['segments-height'], 
e._xseen.attributes['segments-depth']
);
} else if (shape == 'cone') {
geometry = new THREE.ConeGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.height, 
e._xseen.attributes['segments-radial'], 
e._xseen.attributes['segments-height'], 
e._xseen.attributes['open-ended'], 
e._xseen.attributes['theta-start'] * XSeen.CONST.Deg2Rad, 
e._xseen.attributes['theta-length'] * XSeen.CONST.Deg2Rad
);
} else if (shape == 'cylinder') {
geometry = new THREE.CylinderGeometry(
e._xseen.attributes['radius-top'], 
e._xseen.attributes['radius-bottom'], 
e._xseen.attributes.height, 
e._xseen.attributes['segments-radial'], 
e._xseen.attributes['segments-height'], 
e._xseen.attributes['open-ended'], 
e._xseen.attributes['theta-start'] * XSeen.CONST.Deg2Rad, 
e._xseen.attributes['theta-length'] * XSeen.CONST.Deg2Rad
);
} else if (shape == 'dodecahedron') {
geometry = new THREE.DodecahedronGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.detail
);
} else if (shape == 'icosahedron') {
geometry = new THREE.IcosahedronGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.detail
);
} else if (shape == 'octahedron') {
geometry = new THREE.OctahedronGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.detail
);
} else if (shape == 'sphere') {
geometry = new THREE.SphereGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes['segments-width'], 
e._xseen.attributes['segments-height'], 
e._xseen.attributes['phi-start'] * XSeen.CONST.Deg2Rad, 
e._xseen.attributes['phi-length'] * XSeen.CONST.Deg2Rad,
e._xseen.attributes['theta-start'] * XSeen.CONST.Deg2Rad, 
e._xseen.attributes['theta-length'] * XSeen.CONST.Deg2Rad
);
} else if (shape == 'tetrahedron') {
geometry = new THREE.TetrahedronGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.detail
);
} else if (shape == 'torus') {
geometry = new THREE.TorusGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.tube, 
e._xseen.attributes['segments-radial'], 
e._xseen.attributes['segments-tubular'], 
e._xseen.attributes.arc * XSeen.CONST.Deg2Rad
);
} else if (shape == 'tknot') {
geometry = new THREE.TorusKnotGeometry(
e._xseen.attributes.radius, 
e._xseen.attributes.tube, 
e._xseen.attributes['segments-tubular'], 
e._xseen.attributes['segments-radial'], 
e._xseen.attributes['wind-p'], 
e._xseen.attributes['wind-q'], 
);
} else if (shape == 'plane') {
geometry = new THREE.PlaneGeometry(
e._xseen.attributes.width, 
e._xseen.attributes.height, 
e._xseen.attributes['segments-width'], 
e._xseen.attributes['segments-height'], 
);
} else if (shape == 'ring') {
geometry = new THREE.RingGeometry(
e._xseen.attributes['radius-inner'], 
e._xseen.attributes['radius-outer'], 
e._xseen.attributes['segments-theta'], 
e._xseen.attributes['segments-radial'], 
e._xseen.attributes['theta-start'] * XSeen.CONST.Deg2Rad, 
e._xseen.attributes['theta-length'] * XSeen.CONST.Deg2Rad
);
} else {
geometry = new THREE.Geometry();
}
return geometry;
};
XSeen.Tags.material = {
'init'	: function (e,p)
{
var material = XSeen.Tags._appearance (e);
e._xseen.tagObject = material;
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.geometry = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, e._xseen.attributes.shape);
e._xseen.tagObject = geometry;
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.box = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'box');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.cone = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'cone');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.cylinder = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'cylinder');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.dodecahedron = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'dodecahedron');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.icosahedron = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'icosahedron');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.octahedron = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'octahedron');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.sphere = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'sphere');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.tetrahedron = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'tetrahedron');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.torus = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'torus');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.tknot = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'tknot');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.plane = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'plane');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.ring = {
'init'	: function (e,p)
{
var geometry = XSeen.Tags._geometry (e, 'ring');
XSeen.Tags._solid (e, p, geometry);
},
'fin'	: function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.attribute = {
'init':	function (e, p)
{
var attributeName = e._xseen.attributes.attribute.toLowerCase();
if (typeof (p._xseen.attributes[attributeName]) != 'undefined') {
var attrs = XSeen.Parser.getAttrInfo (p.localName.toLowerCase(), attributeName);
var values = XSeen.Parser.parseArrayValue (e.textContent, attrs.elementCount, attrs.dataType, attrs.default);
p._xseen.attributes[attributeName] = values;
}
},
'fin':	function (e,p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.triangles = {
'init'	: function (e,p) 
{
e._xseen.geometry = new THREE.Geometry();
},
'fin'	: function (e,p) 
{
var face;
e._xseen.attributes.index.forEach (function(faceIndex) {
face = new THREE.Face3 (faceIndex[0], faceIndex[1], faceIndex[2]); // , normal/normal3, color/color3, materialIndex
e._xseen.geometry.faces.push(face); 
});
e._xseen.geometry.computeFaceNormals();
e._xseen.geometry.computeVertexNormals();
XSeen.Tags._solid (e, p, e._xseen.geometry);
},
'event'	: function (ev, attr) {},
};
XSeen.Tags.points = {
'init'	: function (e,p) {},
'fin'	: function (e,p)
{
if (typeof(p._xseen.geometry) != 'undefined') {
e._xseen.attributes.vertices.forEach (function(vertex) {
p._xseen.geometry.vertices.push (vertex);
});
}
},
'event'	: function (ev, attr) {},
};
XSeen.Tags.normals = {
'init'	: function (e,p) {},
'fin'	: function (e,p)
{
if (count(e._xseen.attributes.vectors) >= 1) {
p._xseen.normals = e._xseen.attributes.vectors;
p._xseen.normalsDefined = true;
} else {
p._xseen.normals = [];
p._xseen.normalsDefined = false;
}
},
'event'	: function (ev, attr) {},
};
XSeen.Parser._addStandardAppearance = function (tag) {
tag
.defineAttribute ({'name':'selectable', dataType:'boolean', 'defaultValue':true, enumeration:[true,false], isCaseInsensitive:true})
.defineAttribute ({'name':'type', dataType:'string', 'defaultValue':'phong', enumeration:['wireframe', 'phong','pbr'], isCaseInsensitive:true})
.defineAttribute ({'name':'geometry', dataType:'string', 'defaultValue':'', isCaseInsensitive:false})
.defineAttribute ({'name':'material', dataType:'string', 'defaultValue':'', isCaseInsensitive:false})
.defineAttribute ({'name':'emissive-intensity', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'opacity', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'transparent', dataType:'boolean', 'defaultValue':false})
.defineAttribute ({'name':'reflectivity', dataType:'float', 'defaultValue':0.5})
.defineAttribute ({'name':'refraction-ratio', dataType:'float', 'defaultValue':0.98})
.defineAttribute ({'name':'metalness', dataType:'float', 'defaultValue':0.5})
.defineAttribute ({'name':'roughness', dataType:'float', 'defaultValue':0.5})
.defineAttribute ({'name':'shininess', dataType:'float', 'defaultValue':30})
.defineAttribute ({'name':'specular', dataType:'color', 'defaultValue':'#111111'})
.defineAttribute ({'name':'ambient-occlusion-map', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'ambient-occlusion-map-intensity', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'color', dataType:'color', 'defaultValue':'white'})
.defineAttribute ({'name':'displacement-bias', dataType:'float', 'defaultValue':0.5})
.defineAttribute ({'name':'displacement-map', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'displacement-scale', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'emissive', dataType:'color', 'defaultValue':'black'})
.defineAttribute ({'name':'env-map', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'fog', dataType:'boolean', 'defaultValue':true})
.defineAttribute ({'name':'map', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'metalness', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'normal-map', dataType:'string', 'defaultValue':''})
.defineAttribute ({'name':'normal-scale', dataType:'vec2', 'defaultValue':[1,1]})
.defineAttribute ({'name':'side', dataType:'string', 'defaultValue':'front', enumeration:['front','back','both'], isCaseInsensitive:true})
.defineAttribute ({'name':'wireframe', dataType:'boolean', 'defaultValue':false})
.defineAttribute ({'name':'wireframe-linewidth', dataType:'integer', 'defaultValue':2})
.addEvents ({'mutation':[{'attributes':XSeen.Tags.Solids._changeAttribute}]})
.addTag();
};
XSeen.Parser.defineTag ({
'name'	: 'attribute',
'init'	: XSeen.Tags.attribute.init,
'fin'	: XSeen.Tags.attribute.fin,
'event'	: XSeen.Tags.attribute.event,
'tick'	: XSeen.Tags.attribute.tick
})
.defineAttribute ({'name':'attribute', dataType:'string', 'defaultValue':''})
.addTag();
var tag;
tag = XSeen.Parser.defineTag ({
'name'	: 'box',
'init'	: XSeen.Tags.box.init,
'fin'	: XSeen.Tags.box.fin,
'event'	: XSeen.Tags.box.event,
'tick'	: XSeen.Tags.box.tick
})
.addSceneSpace()
.defineAttribute ({'name':'depth', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'height', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'width', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'segments-depth', dataType:'integer', 'defaultValue':1})
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':1})
.defineAttribute ({'name':'segments-width', dataType:'integer', 'defaultValue':1});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'cone',
'init'	: XSeen.Tags.cone.init,
'fin'	: XSeen.Tags.cone.fin,
'event'	: XSeen.Tags.cone.event,
'tick'	: XSeen.Tags.cone.tick
})
.addSceneSpace()
.defineAttribute ({'name':'height', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'open-ended', dataType:'boolean', 'defaultValue':false})
.defineAttribute ({'name':'theta-start', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'theta-length', dataType:'float', 'defaultValue':360.0})
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':1})
.defineAttribute ({'name':'segments-radial', dataType:'integer', 'defaultValue':8});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'cylinder',
'init'	: XSeen.Tags.cylinder.init,
'fin'	: XSeen.Tags.cylinder.fin,
'event'	: XSeen.Tags.cylinder.event,
'tick'	: XSeen.Tags.cylinder.tick
})
.addSceneSpace()
.defineAttribute ({'name':'height', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'open-ended', dataType:'boolean', 'defaultValue':false})
.defineAttribute ({'name':'radius-bottom', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'radius-top', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'theta-start', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'theta-length', dataType:'float', 'defaultValue':360.0})
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':1})
.defineAttribute ({'name':'segments-radial', dataType:'integer', 'defaultValue':8});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'dodecahedron',
'init'	: XSeen.Tags.dodecahedron.init,
'fin'	: XSeen.Tags.dodecahedron.fin,
'event'	: XSeen.Tags.dodecahedron.event,
'tick'	: XSeen.Tags.dodecahedron.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'detail', dataType:'float', 'defaultValue':0.0});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'icosahedron',
'init'	: XSeen.Tags.icosahedron.init,
'fin'	: XSeen.Tags.icosahedron.fin,
'event'	: XSeen.Tags.icosahedron.event,
'tick'	: XSeen.Tags.icosahedron.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'detail', dataType:'float', 'defaultValue':0.0});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'octahedron',
'init'	: XSeen.Tags.octahedron.init,
'fin'	: XSeen.Tags.octahedron.fin,
'event'	: XSeen.Tags.octahedron.event,
'tick'	: XSeen.Tags.octahedron.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'detail', dataType:'float', 'defaultValue':0.0});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'sphere',
'init'	: XSeen.Tags.sphere.init,
'fin'	: XSeen.Tags.sphere.fin,
'event'	: XSeen.Tags.sphere.event,
'tick'	: XSeen.Tags.sphere.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'theta-start', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'theta-length', dataType:'float', 'defaultValue':180.0})
.defineAttribute ({'name':'phi-start', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'phi-length', dataType:'float', 'defaultValue':360.0})
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':18})
.defineAttribute ({'name':'segments-width', dataType:'integer', 'defaultValue':36});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'tetrahedron',
'init'	: XSeen.Tags.tetrahedron.init,
'fin'	: XSeen.Tags.tetrahedron.fin,
'event'	: XSeen.Tags.tetrahedron.event,
'tick'	: XSeen.Tags.tetrahedron.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'detail', dataType:'float', 'defaultValue':0.0});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'torus',
'init'	: XSeen.Tags.torus.init,
'fin'	: XSeen.Tags.torus.fin,
'event'	: XSeen.Tags.torus.event,
'tick'	: XSeen.Tags.torus.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':2.0})
.defineAttribute ({'name':'tube', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'arc', dataType:'float', 'defaultValue':360})
.defineAttribute ({'name':'segments-radial', dataType:'integer', 'defaultValue':8})
.defineAttribute ({'name':'segments-tubular', dataType:'integer', 'defaultValue':6});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'tknot',
'init'	: XSeen.Tags.tknot.init,
'fin'	: XSeen.Tags.tknot.fin,
'event'	: XSeen.Tags.tknot.event
})
.addSceneSpace()
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'tube', dataType:'float', 'defaultValue':0.4})
.defineAttribute ({'name':'segments-radial', dataType:'integer', 'defaultValue':8})
.defineAttribute ({'name':'segments-tubular', dataType:'integer', 'defaultValue':64})
.defineAttribute ({'name':'wind-p', dataType:'integer', 'defaultValue':2})
.defineAttribute ({'name':'wind-q', dataType:'integer', 'defaultValue':3});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'plane',
'init'	: XSeen.Tags.plane.init,
'fin'	: XSeen.Tags.plane.fin,
'event'	: XSeen.Tags.plane.event,
'tick'	: XSeen.Tags.plane.tick
})
.addSceneSpace()
.defineAttribute ({'name':'height', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'width', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':1})
.defineAttribute ({'name':'segments-width', dataType:'integer', 'defaultValue':1});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'ring',
'init'	: XSeen.Tags.ring.init,
'fin'	: XSeen.Tags.ring.fin,
'event'	: XSeen.Tags.ring.event,
'tick'	: XSeen.Tags.ring.tick
})
.addSceneSpace()
.defineAttribute ({'name':'radius-inner', dataType:'float', 'defaultValue':0.5})
.defineAttribute ({'name':'radius-outer', dataType:'float', 'defaultValue':1.0})
.defineAttribute ({'name':'theta-start', dataType:'float', 'defaultValue':0.0})
.defineAttribute ({'name':'theta-length', dataType:'float', 'defaultValue':360.0})
.defineAttribute ({'name':'segments-theta', dataType:'integer', 'defaultValue':8})
.defineAttribute ({'name':'segments-radial', dataType:'integer', 'defaultValue':8});
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'triangles',
'init'	: XSeen.Tags.triangles.init,
'fin'	: XSeen.Tags.triangles.fin,
'event'	: XSeen.Tags.triangles.event,
'tick'	: XSeen.Tags.triangles.tick
})
.addSceneSpace()
.defineAttribute ({'name':'index', dataType:'integer', 'defaultValue':[], isArray:true, elementCount:3, });
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'points',
'init'	: XSeen.Tags.points.init,
'fin'	: XSeen.Tags.points.fin,
'event'	: XSeen.Tags.points.event,
'tick'	: XSeen.Tags.points.tick
})
.defineAttribute ({'name':'vertices', dataType:'xyz', 'defaultValue':[], isArray:true, })
.addTag();
tag = XSeen.Parser.defineTag ({
'name'	: 'normals',
'init'	: XSeen.Tags.normals.init,
'fin'	: XSeen.Tags.normals.fin,
'event'	: XSeen.Tags.normals.event,
'tick'	: XSeen.Tags.normals.tick
})
.defineAttribute ({'name':'vectors', dataType:'xyz', 'defaultValue':[], isArray:true, })
.addTag();
tag = XSeen.Parser.defineTag ({
'name'	: 'material',
'init'	: XSeen.Tags.material.init,
'fin'	: XSeen.Tags.material.fin,
'event'	: XSeen.Tags.material.event,
'tick'	: XSeen.Tags.material.tick
})
XSeen.Parser._addStandardAppearance (tag);
tag = XSeen.Parser.defineTag ({
'name'	: 'geometry',
'init'	: XSeen.Tags.geometry.init,
'fin'	: XSeen.Tags.geometry.fin,
'event'	: XSeen.Tags.geometry.event,
'tick'	: XSeen.Tags.geometry.tick
})
.defineAttribute ({'name':'shape', dataType:'string', 'defaultValue':'box', 
enumeration:['box', 'cone', 'cylinder', 'dodecahedron', 'icosahedron', 'octahedron', 'sphere', 'tetrahedron', 'torus', 'tknot', 'plane', 'ring'], 
isCaseInsensitive:true})
.defineAttribute ({'name':'depth', dataType:'float', 'defaultValue':1.0})				// box
.defineAttribute ({'name':'height', dataType:'float', 'defaultValue':1.0})				// box, cone, cylinder, plane, 
.defineAttribute ({'name':'width', dataType:'float', 'defaultValue':1.0})				// box, plane, 
.defineAttribute ({'name':'segments-depth', dataType:'integer', 'defaultValue':1})		// box
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':1})		// box, cone, cylinder, plane, 
.defineAttribute ({'name':'segments-width', dataType:'integer', 'defaultValue':1})		// box, sphere, plane, 
.defineAttribute ({'name':'radius', dataType:'float', 'defaultValue':1.0})				// cone, dodecahedron, icosahedron, octahedron, sphere, tetrahedron, torus, tknot, 
.defineAttribute ({'name':'open-ended', dataType:'boolean', 'defaultValue':false})		// cone, cylinder, 
.defineAttribute ({'name':'theta-start', dataType:'float', 'defaultValue':1.0})			// cone, cylinder, sphere, ring, 
.defineAttribute ({'name':'theta-length', dataType:'float', 'defaultValue':360.0})		// cone, cylinder, sphere, ring, 
.defineAttribute ({'name':'segments-height', dataType:'integer', 'defaultValue':1})		// cone
.defineAttribute ({'name':'segments-radial', dataType:'integer', 'defaultValue':8})		// cone, cylinder, torus, tknot, ring, 
.defineAttribute ({'name':'radius-bottom', dataType:'float', 'defaultValue':1.0})		// cylinder
.defineAttribute ({'name':'radius-top', dataType:'float', 'defaultValue':1.0})			// cylinder
.defineAttribute ({'name':'detail', dataType:'float', 'defaultValue':0.0})				// dodecahedron, icosahedron, octahedron, tetrahedron
.defineAttribute ({'name':'phi-start', dataType:'float', 'defaultValue':0.0})			// sphere
.defineAttribute ({'name':'phi-length', dataType:'float', 'defaultValue':360.0})		// sphere
.defineAttribute ({'name':'tube', dataType:'float', 'defaultValue':1.0})				// torus, tknot, 
.defineAttribute ({'name':'arc', dataType:'float', 'defaultValue':360})					// torus
.defineAttribute ({'name':'segments-tubular', dataType:'integer', 'defaultValue':6})	// torus, tknot, 
.defineAttribute ({'name':'wind-p', dataType:'integer', 'defaultValue':2})				// tknot
.defineAttribute ({'name':'wind-q', dataType:'integer', 'defaultValue':3})				// tknot
.defineAttribute ({'name':'radius-inner', dataType:'float', 'defaultValue':0.5})		// ring
.defineAttribute ({'name':'radius-outer', dataType:'float', 'defaultValue':1.0})		// ring
.defineAttribute ({'name':'segments-theta', dataType:'integer', 'defaultValue':8})		// ring
.defineAttribute ({'name':'index', dataType:'integer', 'defaultValue':[], isArray:true, elementCount:3, }) // triangles
.addTag();
XSeen.Tags.Style3d = {};
XSeen.Tags.Style3d._changeAttribute = function (e, attributeName, value) {
console.log ('Changing attribute ' + attributeName + ' of ' + e.localName + '#' + e.id + ' to |' + value + ' (' + e.getAttribute(attributeName) + ')|');
if (value !== null) {
var ruleset, nodeAttributes, styleValue, styleProperty, changeSelector;
if (e._xseen.ruleset.complete) {
ruleset = e._xseen.ruleset;
nodeAttributes = e._xseen.attributes;
} else {
ruleset = e.parentNode._xseen.ruleset;
nodeAttributes = e.parentNode._xseen.attributes;
}
if (attributeName == 'property') {
if (nodeAttributes.property != '') {
var oldProperty = nodeAttributes.property;
for (var ii=0; ii<ruleset.declaration.length; ii++) {
if (ruleset.declaration[ii].property == oldProperty) {
ruleset.declaration[ii].property = value;
styleValue = nodeAttributes.value;
styleProperty = oldProperty;
}
}
}
changeSelector = false;
} else if (attributeName == 'value') {
if (nodeAttributes.property != '') {
for (var ii=0; ii<ruleset.declaration.length; ii++) {
if (ruleset.declaration[ii].property == nodeAttributes.property) {
ruleset.declaration[ii].value = value;
styleValue = value;
styleProperty = nodeAttributes.property;
}
}
}
changeSelector = false;
} else if (attributeName == 'selector') {
ruleset.selector = value;
nodeAttributes.selector = value;
changeSelector = true;
}
e._xseen.attributes[attributeName] = value;
var eles = document.querySelectorAll (ruleset.selector);
eles.forEach (function(item) {
for (var ii=0; ii<ruleset.declaration.length; ii++) {
item.setAttribute(ruleset.declaration[ii].property, ruleset.declaration[ii].value);
}
});
} else {
XSeen.LogWarn("Reparse of " + attributeName + " is invalid -- no change")
}
};
XSeen.Tags._style = 
function (property, value, selector, id, ruleParent) {
if (typeof(ruleParent) === 'undefined' || typeof(ruleParent._xseen.styleDefinition) === 'undefined') {
this.id				= id || '';
this.selector		= selector;
this.complete		= true;
this.declaration	= [];
if (property != '') this.declaration.push({'property':property, 'value':value});
} else {
this.complete 		= false;
ruleParent._xseen.ruleset.declaration.push({'property':property, 'value':value});
}
return this;
};
XSeen.Tags.style3d = {
'init'	: function (e, p) 
{
e._xseen.ruleset = new XSeen.Tags._style (e._xseen.attributes.property, e._xseen.attributes.value, e._xseen.attributes.selector, e.id, p);
if (e._xseen.ruleset.complete) {
e._xseen.sceneInfo.StyleRules.ruleset.push (e._xseen.ruleset);
if (e.id != '') e._xseen.sceneInfo.StyleRules.idLookup[e.id] = e._xseen.ruleset;
}
},
'fin'	: function (e, p) {},
'event'	: function (ev, attr) {},
};
XSeen.Tags.class3d = {
'init'	: function (e, p) 
{
e._xseen.styleDefinition = true;
e._xseen.ruleset = new XSeen.Tags._style ('', '', e._xseen.attributes.selector, e.id);
},
'fin'	: function (e, p) 
{
e._xseen.sceneInfo.StyleRules.ruleset.push (e._xseen.ruleset);
if (e.id != '') e._xseen.sceneInfo.StyleRules.idLookup[e.id] = e._xseen.ruleset;
},
'event'	: function (ev, attr) {},
};
XSeen.Parser.defineTag ({
'name'	: 'style3d',
'init'	: XSeen.Tags.style3d.init,
'fin'	: XSeen.Tags.style3d.fin,
'event'	: XSeen.Tags.style3d.event
})
.defineAttribute ({'name':'selector', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'property', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'value', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.addEvents ({'mutation':[{'attributes':XSeen.Tags.Style3d._changeAttribute}]})
.addTag();
XSeen.Parser.defineTag ({
'name'	: 'class3d',
'init'	: XSeen.Tags.class3d.init,
'fin'	: XSeen.Tags.class3d.fin,
'event'	: XSeen.Tags.class3d.event
})
.defineAttribute ({'name':'selector', dataType:'string', 'defaultValue':'', 'isAnimatable':false})
.defineAttribute ({'name':'dump', dataType:'boolean', 'defaultValue':false, 'isAnimatable':false})
.addTag();
XSeen.Tags.subscene = {
'init'	: function (e, p) 
{
e._xseen.processedUrl = false;
e._xseen.loadGroup = new THREE.Group();
e._xseen.loadGroup.name = 'External Scene [' + e.id + ']';
XSeen.Tags._setSpace (e._xseen.loadGroup, e._xseen.attributes);
console.log ('Created Inline Group with UUID ' + e._xseen.loadGroup.uuid);
var loader = new THREE.ObjectLoader();
loader.load (e._xseen.attributes.src, XSeen.Tags.subscene.loadSuccess({'e':e, 'p':p}), XSeen.Tags.subscene.loadProgress, XSeen.Tags.subscene.loadFailure);
e._xseen.requestedUrl = true;
e._xseen.tagObject = e._xseen.loadGroup;
p._xseen.children.push(e._xseen.loadGroup);
console.log ('Using Inline Group with UUID ' + e._xseen.loadGroup.uuid);
},
'fin'	: function (e, p) {},
'event'	: function (ev, attr) {},
'tick'	: function (systemTime, deltaTime) {},
'loadProgress' : function (a1) {
console.log ('Progress ('+a1.type+'): ' + a1.timeStamp);
},
'loadFailure' : function (a1) {
console.log ('Failure ('+a1.type+'): ' + a1.timeStamp);
},
'loadSuccess' : function (userdata) {
var e = userdata.e;
var p  = userdata.p;
return function (response) {
e._xseen.processedUrl = true;
e._xseen.requestedUrl = false;
e._xseen.loadText = response;
e._xseen.currentUrl = e._xseen.attributes.src;
console.log ('Success');
console.log("download successful for |"+e.id);
e._xseen.loadGroup.add(response);		// What docs say for ObjectLoader
p._xseen.sceneInfo.SCENE.updateMatrixWorld();
}
}
};
XSeen.Parser.defineTag ({
'name'	: 'subscene',
'init'	: XSeen.Tags.subscene.init,
'fin'	: XSeen.Tags.subscene.fin,
'event'	: XSeen.Tags.subscene.event,
'tick'	: XSeen.Tags.subscene.tick
})
.addSceneSpace()
.defineAttribute ({'name':'src', dataType:'string', 'defaultValue':''})
.addTag();