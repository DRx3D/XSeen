/*
 * XSeen JavaScript library
 *
 * (c)2017, Daly Realism, Los Angeles
 *
 * portions extracted from or inspired by
 * X3DOM JavaScript Library
 * http://www.x3dom.org
 * (C)2009 Fraunhofer IGD, Darmstadt, Germany
 * Dual licensed under the MIT and GPL
 */

 
/*
 * XSeen events.
 * This object is the manager for all XSeen events. Individual nodes may handle events directed to
 * the node (e.g., change an attribute's value).
 *
 *
 * provides method for the creation of events and the general-purpose handler for the XSEEN tag
 * The General Purpose handler mostly captures the event and regenerates a new XSeen event
 *
 *
 *	Note: Cursor events on objects are not automatically generated by the system as they would be
 *		for "regular" HTML objects. It is necessary to cast a ray into the scene and see which objects
 *		(if any) it hits. The closest object to the viewer that allows tracking is used in the event
 *
 * This class supports the creation of the following events
 *	Beginning of each animation frame
 *	Change to the display size
 *	Change to the scene graph (tags & attributes)
 *	An object that intersects the ray from the observer through the scene
 *	User "button" click
 *
 */
 
/*
 * New translation of HTML events to XSeen events
 #	Treat all "touch" (mousedown, finger, etc.) events the same. The same goes
 #	for "untouch" (mouseup,...). 
 #	Is it worthwhile to treat all touch events as a single 'event' type?
 #	That would require user code to handle all touch events, not just "click" or "touchstart"
 #	with a resultant impact on performance; however, since XSeen handles all of those that may
 #	not be significant.
 #
 #	Since HTML separates all of them, do the same; except treat mouse* as a single-touch
 #	equivalent of touch*.
 #	click & dblclick are a little different. They don't have 'touch*' equivalents.
 #	All screen interaction events are HTML5 touch* events and include the following:
 #	* Camera detail (orientation, position, FOV, etc.)
 #	* Screen position
 #	* All event payloads need to contain intersected object details IFF the ray implied 
 #		by the touch intersects an object. Otherwise, the object details are null.
 #	 - Object details are:
 #		- Specific element
 #		- Group element (need to understand this better)
 #		- Hit point (coordinates)
 #		- Object/element (?) world position
 #		- Geometry & appearance details (color, triangle, texture coordinates, normal)
 
 *	HTML5				XSeen (all prefixed with 'xseen-')
 *	 mousedown			 touchstart
 *	 touchstart			 touchstart
 *	 mousemove			 touchmove
 *	 touchmove			 touchmove
 *	 mouseup			 touchend
 *	 touchend			 touchend
 *	 touchcancel		 touchcancel (?)
 *	 click				 touchtap
 *	 dblckick			 touchdbltap
 *	 deviceorientation	 device
 */
 
var XSeen = XSeen || {};
XSeen.Events = {
		'MODE_NAVIGATE'		: 1,
		'MODE_SELECT'		: 2,
		'mode'				: 1,
		'inNavigation'		: function () {return (this.mode == this.MODE_NAVIGATION) ? true : false;},
		'inSelect'			: function () {return (this.mode == this.MODE_SELECT) ? true : false;},
		'redispatch'		: false,
		'object'			: {},
		'tag'				: {},
		'raycaster'			: new THREE.Raycaster(),
		'cursorScreen'		: new THREE.Vector2(),
		'device'			: {'absolute':true, 'pitch':0, 'roll':0, 'yaw':0},
		'Translate'			: {
								'UNKNOWN'		: {event:'xseen-unknown', type:'unknown', source:'unknown'},
								'mousedown'		: {event:'xseen-touch', type:'start'},
								'mouseup'		: {event:'xseen-touch', type:'end'},
								'mousemove'		: {event:'xseen-drag', type:'move'},
								'mouseover'		: {event:'xseen-hover', type:'hover'},
								'click'			: {event:'xseen-touch', type:'click'},
								'dblclick'		: {event:'xseen-touch', type:'click2'},
								'touchstart'	: {event:'xseen-touch', type:'start'},
								'touchend'		: {event:'xseen-touch', type:'end'},
								'touchcancel'	: {event:'xseen-touch', type:'start'},
								'touchmove'		: {event:'xseen-drag', type:'move'},
								'deviceorientation'	: {event:'xseen-device', type:'change'},
								},
		
/*
 * General XSeen event handler. All XSeen events get processed here during the CAPTURE phase
 *	The main types of events are mousedown, mouseup, and mousemove. All click events are proceeded by mousedown
 *
 *	If the cursor is used for navigation and selection, then a mousedown event can switch the mode to selection 
 *	(MODE_SELECT). A mouseup event will switch the mode to navigation (MODE_NAVIGATE). If event mode is locked
 *	then cursor events do not change the mode.
 *
 *	The mode is switched to selection if the cursor is over a selectable object on mousedown.
 *	The mode is switched to navigation on mouseup.
 *	The mousemove event does not change the mode.
 *
 *	TODO: Locked Mode
 *
 */
		'xseen'				: function (ev)
					{
						//console.log ('XSeen event handler - ' + ev.type);
						//console.log ('... ' + ev.x + ', ' + ev.y);
						var xEvents = XSeen.Events;
						var Runtime = ev.currentTarget._xseen.sceneInfo;
						var eventName;
						if (ev.type == 'mousedown' || ev.type == 'touchstart') {
							xEvents.redispatch = true;
							xEvents.mode = xEvents.MODE_SELECT;
							if (ev.type == 'mousedown') {
								xEvents.cursorScreen.x =  ev.clientX * Runtime.Size.iwidth  * 2 - 1;
								xEvents.cursorScreen.y = -ev.clientY * Runtime.Size.iheight * 2 + 1;
							} else if (ev.type == 'touchstart') {
								xEvents.cursorScreen.x =  ev.touches[0].clientX * Runtime.Size.iwidth  * 2 - 1;
								xEvents.cursorScreen.y = -ev.touches[0].clientY * Runtime.Size.iheight * 2 + 1;
							}

							xEvents.raycaster.setFromCamera(xEvents.cursorScreen, Runtime.Camera);
							var hitGeometryList = xEvents.raycaster.intersectObjects (Runtime.selectable, true);
							if (hitGeometryList.length != 0) {
/**
 * TODO: Need to correctly handle hit item and object for dispatch
 * xEvents.hitObject = hitGeometryList[0]
 * hitNode = hitGeometryList[0].object
 *	unless hitGeometryList[0].object.userdata.root defined
 * Use of xEvents.object is discontinued
 */
								xEvents.object = hitGeometryList[0];
								xEvents.tag = xEvents.object.object.userData;
								if (typeof(xEvents.object.object.userData) != 'undefined' && typeof(xEvents.object.object.userData.root) != 'undefined') {
									xEvents.tag = xEvents.tag.root;
								}
								// TODO: Create mousemove listener on root tag (DONE?)
								XSeen.Runtime.RootTag.addEventListener ('mousemove', XSeen.Events.xseen, true);
								XSeen.Runtime.RootTag.addEventListener ('touchmove', XSeen.Events.xseen, true);

							} else {
								xEvents.object = {};
								xEvents.redispatch = false;
								xEvents.mode = xEvents.MODE_NAVIGATION;
							}
						}
						//console.log ('Type, redispatch = ' + ev.type + ', ' + xEvents.redispatch);
						if ((xEvents.redispatch || ev.type == 'click' || ev.type == 'dblclick') && typeof(xEvents.object.object) !== 'undefined') {
							//console.log ('Repropigate event');
							// Generate an XSeen (Custom)Event of the same type and dispatch it
							
							if (typeof(xEvents.Translate[ev.type]) == 'undefined') {
								console.log ('Unknown event type -- ' + ev.type);
								eventName = xEvents.Translate.UNKNOWN.event;
							} else {
								eventName = xEvents.Translate[ev.type].event;
							}
							var newEv = new CustomEvent(eventName, xEvents.propertiesCursor(ev, xEvents.object, xEvents));
							xEvents.tag.dispatchEvent(newEv);
							ev.stopPropagation();		// No propagation beyond this tag
						} else {
							//console.log ('Navigation mode...');
						}
						if (ev.type == 'mouseup' || ev.type == 'touchend' || ev.type == 'touchcancel') {
							// Cancel mousemove EventListener to reduce event traffic and allow navigation to use it
							XSeen.Runtime.RootTag.removeEventListener ('mousemove', XSeen.Events.xseen, true);
							XSeen.Runtime.RootTag.removeEventListener ('touchmove', XSeen.Events.xseen, true);
							xEvents.redispatch = false;
							xEvents.mode = xEvents.MODE_NAVIGATION;
						}
					},

		'propertiesCursor'	: function (ev, selectedObject, xEvents)
					{
						//console.log ('Creating event detail for |' + ev.type + '|');
						var properties = {
								'detail':		{					// This object contains all of the XSeen data
										'type':			xEvents.Translate[ev.type].type,
										'originalType':	ev.type,
										//'originator':	selectedObject.object.userData,
										'originator':	xEvents.tag,
										'picker':		xEvents.tag._xseen.pickGroup,
										'name':			selectedObject.object.name,
										'distance':		selectedObject.distance,
										'target':		selectedObject,
										'position': {				// Deprecated
												'x': selectedObject.point.x,
												'y': selectedObject.point.y,
												'z': selectedObject.point.z,
												},
										'hitPosition': {			// Touch point on target
												'x': selectedObject.point.x,
												'y': selectedObject.point.y,
												'z': selectedObject.point.z,
												},
										'normal': {
												'x': selectedObject.face.normal.x,
												'y': selectedObject.face.normal.y,
												'z': selectedObject.face.normal.z,
												},
										'uv': {
												'x': 0.0,		// selectedObject.uv.x,
												'y': 0.0,		// selectedObject.uv.y,
												},
										'targetWorldPosition': selectedObject.object.getWorldPosition(),
										'pickerWorldPosition': xEvents.tag._xseen.pickGroup._xseen.tagObject.getWorldPosition(),
										'cameraNormal': {		// Where the camera is pointing
												'x': 0,
												'y': 0,
												'z': -1,
												},
										//'cameraPosition': selectedObject.object.userData._xseen.sceneInfo.Camera.getWorldPosition(),
										'cameraPosition': xEvents.tag._xseen.sceneInfo.Camera.getWorldPosition(),
										'deviceOrientation': {	// Device orientation from the browser
												'pitch': 	xEvents.device.pitch,
												'roll':		xEvents.device.roll,
												'yaw':		xEvents.device.yaw,
												},
										'screenX':	0,			// Filled in below
										'screenY':	0,
										'clientX':	0,
										'clientY':	0,
										'ctrlKey':	ev.ctrlKey,
										'shiftKey':	ev.shiftKey,
										'altKey': 	ev.altKey,
										'metaKey':	ev.metaKey,
										'button':	ev.button,
										'buttons':	ev.buttons,
												},
								'bubbles':		ev.bubbles,
								'cancelable':	ev.cancelable,
								'composed':		ev.composed,
							};
						if (typeof(ev.clientX) != 'undefined' && !isNaN(ev.clientX)) {
							properties.detail.clientX = ev.clientX;
							properties.detail.clientY = ev.clientY;
							properties.detail.screenX = ev.screenX;
							properties.detail.screenY = ev.screenY;
						} else if (typeof(ev.touches) != 'undefined' && typeof(ev.touches[0]) != 'undefined' && typeof(ev.touches[0].clientX) != 'undefined' && !isNaN(ev.touches[0].clientX)) {
							properties.detail.clientX = ev.touches[0].clientX;
							properties.detail.clientY = ev.touches[0].clientY;
							properties.detail.screenX = ev.touches[0].screenX;
							properties.detail.screenY = ev.touches[0].screenY;
						}
//						selectedObject.object.getWorldPosition (properties.detail.targetWorldPosition);
//						properties.detail.targetWorldPosition = selectedObject.object.getWorldPosition();
						return  properties;
					},
/*
 *	Events for device state changes
 *	Mostly this is deviceorientation events
 */
		'propertiesDevice'	: function (ev)
					{
						//console.log ('Creating event detail for |' + ev.type + '|');
						var properties = {
								'detail':		{					// This object contains all of the XSeen data
										'type':			XSeen.Events.Translate[ev.type].type,
										'originalType':	ev.type,
										'deviceOrientation': {	// Device orientation from the browser
												'pitch': 	XSeen.Events.device.pitch,
												'roll':		XSeen.Events.device.roll,
												'yaw':		XSeen.Events.device.yaw,
												},
												},
								'bubbles':		ev.bubbles,
								'cancelable':	ev.cancelable,
								'composed':		ev.composed,
							};
						return  properties;
					},

		'propertiesRenderFrame'	: function (Runtime)
					{
						var properties = {
								'detail':		{					// This object contains all of the XSeen data
										'type'			: 'renderframe',
										'originalType'	: 'renderframe',
										'originator'	: Runtime.RootTag,			// Reference to scene object
										'name'			: Runtime.RootTag.name,		// Name of scene object
										'currentTime'	: Runtime.currentTime,		// Current time at start of frame rendering
										'deltaTime'		: Runtime.deltaTime,		// Time since last frame
										'frameNumber'	: Runtime.frameNumber,		// Number of frame about to be rendered
										'Runtime'		: Runtime					// Reference to Runtime object
												},
								'bubbles':		true,
								'cancelable':	true,
								'composed':		true,
							};
						return  properties;
					},

		'propertiesInitialize'	: function (Runtime)
					{
						var properties = {
								'detail':		{					// This object contains all of the XSeen data
										'type'			: 'initialize',
										'originalType'	: 'initialize',
										'originator'	: Runtime.RootTag,			// Reference to scene object
										'name'			: Runtime.RootTag.name,		// Name of scene object
										'currentTime'	: Runtime.currentTime,		// Current time at start of frame rendering
										'deltaTime'		: Runtime.deltaTime,		// Time since last frame
										'Runtime'		: Runtime					// Reference to Runtime object
												},
								'bubbles':		true,
								'cancelable':	true,
								'composed':		true,
							};
						return  properties;
					},
};
/*
 *	The phone's coordinate system has bad breakpoints. The calculations here
 *	convert everything to a RHS with Y-Up with breakpoints at the nadir and zenith.
 *	This assumes that the phone is held landscape. Portrait orientation needs to
 *	be further examined. Most phones are set to auto-rotate so that the top of the
 *	application display is at the current top of the screen.
 *
 *	ev.* units are degrees
 *	XSeen.Events.device units are radians
 */
window.addEventListener('deviceorientation', function(ev) {
	XSeen.Events.device.absolute	= ev.absolute;
	//XSeen.Events.device.alpha		= ev.alpha * 0.0174533;
	//XSeen.Events.device.beta		= ev.beta * 0.0174533;
	//XSeen.Events.device.gamma		= ev.gamma * 0.0174533;
	if (ev.gamma >= 180) {			// phone looking up. 0 is zenith
		XSeen.Events.device.yaw			= ev.alpha * 0.0174533;
		XSeen.Events.device.roll		= ev.beta * 0.0174533;
		XSeen.Events.device.pitch		= (ev.gamma-180) * 0.0174533;
	} else if (ev.gamma >= 0) {			// phone looking up. 0 is zenith
		XSeen.Events.device.yaw			= ev.alpha * 0.0174533;
		XSeen.Events.device.roll		= ev.beta * 0.0174533;
		XSeen.Events.device.pitch		= ev.gamma * 0.0174533;
	} else {
		XSeen.Events.device.yaw			= (180+ev.alpha) * 0.0174533;
		XSeen.Events.device.roll		= ev.beta * 0.0174533;
		XSeen.Events.device.pitch		= (180+ev.gamma) * 0.0174533;
	}

	var newEv = new CustomEvent(XSeen.Events.Translate[ev.type].event, XSeen.Events.propertiesDevice(ev));
//	XSeen.Events.tag.dispatchEvent(newEv);
	ev.currentTarget.dispatchEvent(newEv);
	XSeen.Runtime.RootTag.dispatchEvent(newEv);
	//console.log ("Created '" + XSeen.Events.Translate[ev.type].event + "' event");
	//ev.stopPropagation();		// Allow propagation beyond this tag
	});
/*
Events

Events are created for all user interactions and changes to the DOM scene graph
Unless there is already a system event name (mouseover, click, etc.), all events are Custom
All nodes create event handlers for the following:
  1) Attribute changes
  2) Children changes
  3) Changes to all style nodes used
Changes to styles that have run-time impact (those with non-empty 'selector' value) are pushed to the node

For example a Group (Transform) node defines an event handler for (https://developer.mozilla.org/en-US/docs/Web/Events)
  1) changes to any attribute value
	DOMAttrModified
  2) changes to children
	DOMNodeInserted
	DOMNodeRemoved
	DOMSubtreeModified
  3)[1] for style elements (nodes)
  
In addition the XSEEN node also receives events for all 
 * mouse/cursor/pointer(?) motions
 * clicks & presses
 * full-screen
 * keyboard
 * window/element resize
 
Node events are handled with the 'events' method that is automatically created during node definition.

The event structure contains the initiating node/action and a reference to the target node

It is the responsibility of the node to make all necessary changes. If the event is ignored, then the node should
pass on the event. If it is fully handled, then it should capture it.
 */
